<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Uncle Peter&#39;s Blog</title>
  
  <subtitle>无他,但手熟尔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-02T12:19:39.653Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Uncle Peter</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>swift中copy on write的研究</title>
    <link href="http://yoursite.com/2018/03/05/swift%E4%B8%ADcopy%20on%20write%E7%9A%84%E7%A0%94%E7%A9%B6/"/>
    <id>http://yoursite.com/2018/03/05/swift中copy on write的研究/</id>
    <published>2018-03-05T02:19:49.000Z</published>
    <updated>2018-07-02T12:19:39.653Z</updated>
    
    <content type="html"><![CDATA[<p>本文部分相关知识参考了《Advanced Swift》以及<a href="https://www.boxueio.com" target="_blank" rel="noopener">泊学网</a></p><h1 id="什么是写时复制-copy-on-write"><a href="#什么是写时复制-copy-on-write" class="headerlink" title="什么是写时复制(copy-on-write)"></a>什么是写时复制(copy-on-write)</h1><p>在<code>swift</code>标准库中，像<code>Array</code>,<code>Dictionary</code>,<code>Set</code>这些结构体都实现了写时复制技术，那到底什么是写时复制呢？我们看一个例子就明白了，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> b = a</span><br></pre></td></tr></table></figure><p>如上面的代码所示，我们创建了一个数组<code>a</code>，同时我们将<code>a</code>赋给<code>b</code>，这是很常见的操作，其实这个时候，a和b是两个独立的值，但是在内部，a和b都是指向内存中同一个位置的引用，其实这两个数组共享了他们的存储部分，也就是说在堆内存中只有一份这样的数据，但是a和b都引用了这份数据。如果我们再增加一个操作，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.append(<span class="number">4</span>)<span class="comment">//[1,2,3,4]</span></span><br><span class="line">b<span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure><p>在这种时候，<code>swift</code>就会对内存进行复制，然后在复制的值上进行处理，从而不影响原来的那份值，也就是说只在必要的时候去复制。</p><p>总结一下就是：每当值类型内容发生变化时，它会首先检查对存储缓冲区的引用是否唯一，如果只有自己一个引用，那就在这份存储数据上原地修改即可，不会有复制发生。如果发现对存储缓冲区有不止一个引用，例如上面的例子，那么就会先进行复制，然后对复制的值进行操作，以免影响其他引用。总之只在必要时复制，否则不会复制。</p><p>在标准库中的集合类型，譬如<code>Array</code>,<code>Dictionary</code>,<code>Set</code>这些结构体都实现了写时复制技术，我们只管使用即可，它保持了值语义，同时也优化了性能，避免了昂贵的不必要的复制操作，但是这个福利并不是所有值类型都有，当我们自己创建一些值类型的时候，特别是我们自定义的值类型里包含引用类型对象时，为了保持值语义，我们就得自己来实现<code>copy-on-write</code>了。</p><h1 id="我们自己动手来实现COW"><a href="#我们自己动手来实现COW" class="headerlink" title="我们自己动手来实现COW"></a>我们自己动手来实现COW</h1><h2 id="一个比较粗糙的copy-on-write实现"><a href="#一个比较粗糙的copy-on-write实现" class="headerlink" title="一个比较粗糙的copy-on-write实现"></a>一个比较粗糙的copy-on-write实现</h2><p>譬如我们来实现一个我们自定义的<code>Array</code>，里面用来存储数据的是一个oc对象，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> elements: <span class="type">NSMutableArray</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> elements: <span class="type">NSMutableArray</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.elements = elements.mutableCopy() <span class="keyword">as</span>! <span class="type">NSMutableArray</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了实现值语义，我们将传入的elements复制一份，赋给内部的elements变量。同时，为了在操作<code>CustomArray</code>对象时隐藏<code>elements</code>属性，我们为它添加一个方法，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CustomArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> element: Any)</span></span> &#123;</span><br><span class="line">        elements.insert(element, at: elements.<span class="built_in">count</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们平常会写的代码，但是这样会有问题，看如下操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aArr = <span class="type">CustomArray</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> bArr = aArr</span><br><span class="line">aArr.append(<span class="number">4</span>)</span><br><span class="line">aArr.elements === bArr.elements<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><code>aArr</code>和<code>bArr</code>是两个独立的结构体，按照我们之前对copy-on-write的理解，当<code>aArr</code>内容发生变更时，会被复制一份，那么<code>aArr</code>和<code>bArr</code>将不再享有同一份内存数据，而是两份独立的数据，内存不再共享，但是上面的<code>aArr</code>和<code>bArr</code>中<code>elements</code>却仍旧是同一个引用对象，这个可以理解，因为我们没有对它做任何特殊处理，但是这样子却是不符合值语义的，所以为了保持值语义，我们需要来实现copy-on-write，我们来修改一下代码，我们创建一个计算属性<code>elementsCOW</code>，每当自定义数组需要改变内容时，我们都使用这个计算属性，来对内部的elements进行复制，然后使用这份拷贝来进行操作。相应的<code>append</code>方法都会使用这个计算属性，代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elementsCOW: <span class="type">NSMutableArray</span> &#123;</span><br><span class="line">        <span class="keyword">mutating</span> <span class="keyword">get</span> &#123;</span><br><span class="line">            elements = elements.mutableCopy() <span class="keyword">as</span>! <span class="type">NSMutableArray</span></span><br><span class="line">            <span class="keyword">return</span> elements</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CustomArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> element: Any)</span></span> &#123;</span><br><span class="line">        elementsCOW.insert(element, at: elementsCOW.<span class="built_in">count</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子的话，每次<code>append</code>新的元素，都会对内部<code>elements</code>进行拷贝后，使用拷贝的值进行添加操作，完全符合了值语义，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aArr = <span class="type">CustomArray</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> bArr = aArr</span><br><span class="line">aArr.append(<span class="number">4</span>)</span><br><span class="line">aArr.elements === bArr.elements<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>如果这样就完成了，那就太简单了，<img src="https://i.loli.net/2018/07/02/5b39fae014738.jpg" alt="5b39fae014738"></p><p>如果这样，我们确实为自定义的数组实现了值语义，每次使用修改时，都会复制一份，但是你会发现，如果这样，像上述的例子那样，如果没有<code>bArr</code>，只有一个<code>aArr</code>，我们每次都对<code>aArr</code>进行修改都会被复制一份，譬如这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> &#123;</span><br><span class="line">    aArr.append(i)<span class="comment">//aArr会被复制10次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的<code>aArr</code>会被复制10次，这样太不合理，内存明明只有一个引用，不会影响到其他对象使用，太浪费了。所以我们需要对上述代码在做一次更改，只在必要的时候复制。我们的思路是这样的，当值被更改时，判断对象是否只有一个引用，如果是，那就不复制，如果不是，那就需要复制一份。</p><h2 id="一个更高效的copy-on-write实现"><a href="#一个更高效的copy-on-write实现" class="headerlink" title="一个更高效的copy-on-write实现"></a>一个更高效的copy-on-write实现</h2><p>为此我们需要用到一个方法swift标准库中的<code>isKnownUniquelyReferenced</code>，对于Swift原生类对象，只有单一引用时返回<code>true</code>，否则返回<code>false</code>；对于Objective-C中的类对象，总是返回<code>false</code>，所以我们还不能直接用，我们需要把oc对象封装在swift对象之内，所以我们这样来做，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Pack</span>&lt;<span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> unpack: <span class="type">U</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> unpack: <span class="type">U</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.unpack = unpack</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们自定义一个类型<code>Pack</code>用来打包oc对象，使用<code>final</code>，不想让它被继承。然后我们可以修改一下上面的代码，内部元素<code>elements</code>可以打包，并且判断打包好后的swift类型是否只有唯一引用，不是的话就复制，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> elementsCOW: <span class="type">NSMutableArray</span> &#123;</span><br><span class="line">        <span class="keyword">mutating</span> <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> !isKnownUniquelyReferenced(&amp;elements) &#123;</span><br><span class="line">                elements = <span class="type">Pack</span>(elements.unpack.mutableCopy() <span class="keyword">as</span>! <span class="type">NSMutableArray</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"occur copy"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> elements.unpack</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> elements: <span class="type">Pack</span>&lt;<span class="type">NSMutableArray</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> elements: <span class="type">NSMutableArray</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.elements = <span class="type">Pack</span>(elements.mutableCopy() <span class="keyword">as</span>! <span class="type">NSMutableArray</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，再次执行原先的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> &#123;</span><br><span class="line">    aArr.append(i)<span class="comment">//aArr将不再被复制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，一个更加高效的写时复制完成了，它保证了我们自定义数组的值语义，并且只在必要的时候才去复制。</p><p><img src="https://i.loli.net/2018/07/02/5b3a1499291b6.jpg" alt="5b3a1499291b6"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在swift中，值类型是非常重要的类型，你会发现原来OC中是引用类型的数组，字典等在swift中都是值类型，因为更安全，高效。我们在自定义一些值类型时，为了维护值语义，通常都需要在每次变更时，都进行昂贵的复制操作，但是写时复制技术避免了在非必要的情况下的复制操作。希望以上这些可以帮到你。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文部分相关知识参考了《Advanced Swift》以及&lt;a href=&quot;https://www.boxueio.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;泊学网&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;什么是写时复制-copy-on-write&quot;&gt;
      
    
    </summary>
    
      <category term="swift" scheme="http://yoursite.com/categories/swift/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>swift中map与flatMap的用法与研究</title>
    <link href="http://yoursite.com/2018/02/26/swift%E4%B8%ADmap%E4%B8%8EflatMap%E7%9A%84%E7%94%A8%E6%B3%95%E4%B8%8E%E7%A0%94%E7%A9%B6/"/>
    <id>http://yoursite.com/2018/02/26/swift中map与flatMap的用法与研究/</id>
    <published>2018-02-26T02:19:49.000Z</published>
    <updated>2018-07-02T06:12:03.333Z</updated>
    
    <content type="html"><![CDATA[<p><code>map</code>和<code>flatMap</code>是swift中两个高阶函数，用处很大，其实不仅仅是这两个函数，其他的譬如<code>reduce</code>，<code>filter</code>等等，都为我们提供了很多功能，是之前在oc里无法提供，或者需要自己去实现的。当然这些函数在其他语言里是一直存在的，譬如<code>Haskell</code>。所以<code>swift</code>是一门多编程范式的语言，这里只是记录一下<code>map</code>和<code>flatMap</code>的用法，以及通过这个，我们来看一下函数式思想在<code>swfit</code>中的运用。</p><h1 id="map和flatMap用法"><a href="#map和flatMap用法" class="headerlink" title="map和flatMap用法"></a>map和flatMap用法</h1><p>我们直接看例子：</p><blockquote><p>例1  数组中使用</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.<span class="built_in">map</span> &#123;$<span class="number">0</span> + <span class="number">1</span>&#125;<span class="comment">//[2,3,4],将数组中每一个整数加一然后返回,返回值类型是Array</span></span><br><span class="line"><span class="keyword">let</span> arr3 = arr.flatMap &#123;[$<span class="number">0</span> - <span class="number">1</span>, $<span class="number">0</span> + <span class="number">1</span>]&#125;<span class="comment">//[0, 2, 1, 3, 2, 4]，将数组中每一个整型元素映射成了一个数组，如果用map将会得到一个二维数组，所以用flatmap降维成一维数组</span></span><br></pre></td></tr></table></figure><blockquote><p>例2  数组的<code>flatMap</code>(在swift4.1中，已经改名为compactMap,下面的源码也贴了出来)还有另外一种用法</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> brr = [<span class="string">"1"</span>, <span class="string">"2"</span>,<span class="string">"三"</span>, <span class="string">"4"</span>]</span><br><span class="line"><span class="comment">//let brr2 = brr.compactMap &#123;Int($0)&#125;</span></span><br><span class="line"><span class="keyword">let</span> brr2 = brr.flatMap &#123;<span class="type">Int</span>($<span class="number">0</span>)&#125;<span class="comment">//[1, 2, 4],Int()函数将String转成Int类型，有可能成功，也有可能失败，所以返回值类型是Optional&lt;Int&gt;,很明显这边数组brr里的"三"是无法成功转换成整型3的，所以返回nil，结果是[1,2,nil,4],此时的flatMap可以过滤掉了nil</span></span><br></pre></td></tr></table></figure><p>因为这个<code>flatMap</code>除了 降维之外其实还有 filter 的作用，在使用时容易产生歧义，所以社区认为最好把这个flatMap重新拆分出来，使用一个新的方法命名，所以就有了<code>compactMap</code>。</p><blockquote><p>例3  <code>optional</code>中使用</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str: <span class="type">String</span>? = <span class="string">"12"</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = str.<span class="built_in">map</span> &#123;$<span class="number">0</span>.<span class="built_in">count</span>&#125;<span class="comment">//count = 2,如果这个str有值，就计算这个string的字符个数，如果没有值，就返回nil，注意count的类型为Optional&lt;Int&gt;</span></span><br><span class="line"><span class="keyword">let</span> value = str.flatMap &#123;<span class="type">Int</span>($<span class="number">0</span>)&#125;<span class="comment">//value = 12,和上面数组中使用一样，Int()函数将String转成Int类型，有可能成功，也有可能失败，所以返回值类型是Optional&lt;Int&gt;，此时如果使用map，那么value返回的类型会变成Optional&lt;Optional&lt;Int&gt;&gt;，嵌套的optional，所以使用flatMap，其实也是降维的概念，使其返回类型变为Optional&lt;Int&gt;。</span></span><br></pre></td></tr></table></figure><h1 id="map和flatMap在标准库中的实现"><a href="#map和flatMap在标准库中的实现" class="headerlink" title="map和flatMap在标准库中的实现"></a>map和flatMap在标准库中的实现</h1><p>没有什么比看源码更能直接了当的了解一个类或者方法了，大家也可以直接去<a href="https://github.com/apple/swift/tree/master/stdlib/public/core" target="_blank" rel="noopener">swift源码</a>查看。我们会发现，<code>sequence</code>和<code>optional</code>都实现了这两个方法，如下所示：</p><blockquote><p><code>sequence</code>中<code>map</code>和<code>flatMap</code> 的实现</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span></span><br><span class="line">  ) <span class="keyword">rethrows</span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">    <span class="keyword">let</span> initialCapacity = underestimatedCount</span><br><span class="line">    <span class="keyword">var</span> result = <span class="type">ContiguousArray</span>&lt;<span class="type">T</span>&gt;()</span><br><span class="line">    result.reserveCapacity(initialCapacity)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> iterator = <span class="keyword">self</span>.makeIterator()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add elements up to the initial capacity without checking for regrowth.</span></span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;initialCapacity &#123;</span><br><span class="line">      result.append(<span class="keyword">try</span> transform(iterator.next()!))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add remaining elements, if any.</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> element = iterator.next() &#123;</span><br><span class="line">      result.append(<span class="keyword">try</span> transform(element))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Array</span>(result)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;SegmentOfResult : Sequence&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">SegmentOfResult</span></span><br><span class="line">  ) <span class="keyword">rethrows</span> -&gt; [<span class="type">SegmentOfResult</span>.<span class="type">Element</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> result: [<span class="type">SegmentOfResult</span>.<span class="type">Element</span>] = []</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">      result.append(contentsOf: <span class="keyword">try</span> transform(element))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;ElementOfResult&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">ElementOfResult</span>?</span><br><span class="line">  ) <span class="keyword">rethrows</span> -&gt; [<span class="type">ElementOfResult</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> _compactMap(transform)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">_compactMap</span>&lt;ElementOfResult&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">ElementOfResult</span>?</span><br><span class="line">  ) <span class="keyword">rethrows</span> -&gt; [<span class="type">ElementOfResult</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> result: [<span class="type">ElementOfResult</span>] = []</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> newElement = <span class="keyword">try</span> transform(element) &#123;</span><br><span class="line">        result.append(newElement)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>optional</code>中<code>map</code>和<code>flatMap</code>的实现</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> transform: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">U</span></span><br><span class="line">  ) <span class="keyword">rethrows</span> -&gt; <span class="type">U</span>? &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .some(<span class="keyword">let</span> y):</span><br><span class="line">      <span class="keyword">return</span> .some(<span class="keyword">try</span> transform(y))</span><br><span class="line">    <span class="keyword">case</span> .<span class="keyword">none</span>:</span><br><span class="line">      <span class="keyword">return</span> .<span class="keyword">none</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;U&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> transform: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">U</span>?</span><br><span class="line">  ) <span class="keyword">rethrows</span> -&gt; <span class="type">U</span>? &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .some(<span class="keyword">let</span> y):</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">try</span> transform(y)</span><br><span class="line">    <span class="keyword">case</span> .<span class="keyword">none</span>:</span><br><span class="line">      <span class="keyword">return</span> .<span class="keyword">none</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看完源码实现，大家就能够明白上面的用法了，这里就不赘述了，不过我们需要透过现象看本质，看一看Apple到底为什么要这样来设计，他的思想是什么。</p><p>所以，我们来捋一捋，去掉各种不重要的符号，以及<code>sequence</code>中第二个版本的<code>flatMap</code>已经更名为<code>compactMap</code>,表意更清晰，所以也不会混淆了，所以也暂时去掉他，那么<code>sequence</code>和<code>optional</code>中的定义如下：</p><blockquote><p><code>sequence</code>:</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(transform: <span class="params">(Element)</span></span></span> -&gt; <span class="type">T</span>) -&gt; [<span class="type">T</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;SegmentOfResult : Sequence&gt;<span class="params">(transform: <span class="params">(Element)</span></span></span> -&gt; <span class="type">SegmentOfResult</span>) -&gt; [<span class="type">SegmentOfResult</span>.<span class="type">Element</span>]</span><br></pre></td></tr></table></figure><blockquote><p><code>optional</code>:</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(transform: <span class="params">(Wrapped)</span></span></span> -&gt; <span class="type">U</span>) -&gt; <span class="type">U</span>?</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;U&gt;<span class="params">(transform: <span class="params">(Wrapped)</span></span></span> -&gt; <span class="type">U</span>?) -&gt; <span class="type">U</span>?</span><br></pre></td></tr></table></figure><p>我们会发现，<code>sequence</code>中<code>map</code>与<code>flatMap</code>方法的区别主要在于transform方法，一个将element转换为<code>T</code>类型，一个将element转换为<code>sequence</code>类型</p><p>同理，<code>optional</code>中<code>map</code>与<code>flatMap</code>方法的区别主要也在于transform方法，一个将解包后的值转换为<code>U</code>类型，一个将解包后的值转换为<code>U?</code>类型。</p><p>为什么<code>sequence</code>和<code>optional</code>都有这两个方法，有什么关联吗，这个需要我们来了解一下函数式编程一些知识。</p><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>其实很难给出函数式的准确定义，不过有几个概念是函数式编程中经常会遇到的，<code>Functor</code>，<code>Applicative</code>和<code>Monad</code>，之前对这个了解也不是很深，直到后面看到一篇文章，讲的很通俗易懂，想看小伙伴可以点击<a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="noopener">这里</a>来查看原文。</p><h2 id="封装值"><a href="#封装值" class="headerlink" title="封装值"></a>封装值</h2><p>其实这里有一个封装值的概念，我们在编程的时候用到很多基础类型值，譬如3就是一个整型，但是包装值的概念是将整型3放入其中，将其封装起来，对外表现出的类型已经不是整型，可以是其他类型，<code>swift</code>中有一个绝佳的例子<code>enum</code>的Associated Value 如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> success(<span class="type">T</span>)</span><br><span class="line">  <span class="keyword">case</span> fail</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="type">Result</span>.success(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>如上所示，整型3被封装了起来，对外的类型是<code>enum</code>，这就是封装值的概念，下面的诸多例子我们都会用这个<code>Result</code>来演示。</p><p>其实<code>optional</code>就是用<code>enum</code>来实现的如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">None</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Some</span>(<span class="type">T</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以大家该明白了，<code>optional</code>就是一种封装值。</p><h2 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h2><p>我们平时写代码用的最多的函数是处理普通值函数的代码，譬如如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(<span class="number">_</span> number: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = addOne(a)<span class="comment">//b = 2</span></span><br></pre></td></tr></table></figure><p>但是，如果我们把上述的整型a变成封装值，上述的<code>addOne()</code>函数就无法工作了，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="type">Result</span>.success(<span class="number">1</span>)<span class="comment">//a已经变成了一个封装值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(<span class="number">_</span> number: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = addOne(a)<span class="comment">//报错，提示a类型不是Int类型</span></span><br></pre></td></tr></table></figure><p>这时候，我们就需要将封装值从它封装的类型<code>Result</code>里拿出来，再传给<code>addOne()</code>函数，才能正常工作，然后将通过<code>addOne()</code>函数计算好后得到的普通结果值再次封装在<code>Result</code>里，返回这个封装结果值，这个过程就是<code>Functor</code>.</p><p>我们来实现这个<code>Functor</code>，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functor</span><span class="params">(<span class="number">_</span> result: Result&lt;Int&gt;, transform: <span class="params">(Int)</span></span></span>-&gt; <span class="type">Int</span>) -&gt; <span class="type">Result</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .success(value):</span><br><span class="line">        <span class="keyword">return</span> .success(transform(value))</span><br><span class="line">    <span class="keyword">case</span> .fail:</span><br><span class="line">        <span class="keyword">return</span> .fail</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = functor(a, transform: addOne)<span class="comment">//b = .success(2)</span></span><br></pre></td></tr></table></figure><p>如果大家把这个<code>functor</code>函数和上面源码中<code>sequence</code>和<code>optional</code>中<code>map</code>方法的实现比照，就会发现，<code>sequence</code>和<code>optional</code>中的<code>map</code>方法就是<code>Functor</code>思想在<code>swift</code>中的实现，有同学会说<code>sequence</code>中的<code>map</code>好像不是啊，其实如果把数组也看作一种封装值，那就是一样的啦。</p><p><img src="https://i.loli.net/2018/06/28/5b349e05a1db4.jpg" alt="5b349e05a1db4"></p><h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><p>继续上面的例子，如果我们不仅仅a变成封装值，我们的<code>addOne()</code>函数的返回值不再是<code>Int</code>,而是一个封装值，譬如<code>Result&lt;Int&gt;</code>，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(<span class="number">_</span> number: Int)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Result</span>.success(number + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那整个计算过程就需要少许改变一下了，因为我们现在的<code>addOne()</code>函数也返回封装值，如果在用刚刚的<code>functor</code>函数，那返回值就会出现封装值里面嵌套封装值，啊，这绝对是我们不想看到的，我们来修改一下<code>functor</code>函数，取个新函数名<code>monad</code>如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">monad</span><span class="params">(<span class="number">_</span> result: Result&lt;Int&gt;, transform: <span class="params">(Int)</span></span></span>-&gt; <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .success(value):</span><br><span class="line">        <span class="keyword">return</span> transform(value)</span><br><span class="line">    <span class="keyword">case</span> .fail:</span><br><span class="line">        <span class="keyword">return</span> .fail</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = monad(a, transform: addOne)<span class="comment">//c = .success(2)</span></span><br></pre></td></tr></table></figure><p>如果大家把这个<code>monad</code>函数和上面源码中<code>sequence</code>和<code>optional</code>中<code>flatMap</code>方法的实现比照，就会发现，<code>sequence</code>和<code>optional</code>中的<code>flatMap</code>方法就是<code>Monad</code>思想在<code>swift</code>中的实现。</p><p>但是<code>Monad</code>绝对不仅仅是降维这么简单，它真正厉害的地方是可以将多个函数串联起来，将原来一个完整的流程拆分为多个函数的串联，每个函数完成一个单独的功能，串联起来实现一个复杂的功能，我觉得<code>Monad</code>不单单是个函数，更多的是一种思想，一种解决问题的思路。</p><p>我们看一个用这个思想解决的一个问题。</p><h2 id="用函数式思想解决网络请求问题"><a href="#用函数式思想解决网络请求问题" class="headerlink" title="用函数式思想解决网络请求问题"></a>用函数式思想解决网络请求问题</h2><p>大家经常遇到这样的需求，判断有没有网络-&gt;获取接口数据成功与否-&gt;解析数据成功与否-&gt;保存数据成功与否，为了演示，我写了几个函数如下方便大家理解：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkNet</span><span class="params">()</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Bool</span>&gt;<span class="comment">//检查网络</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchData</span><span class="params">(canFetch: Bool)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Data</span>&gt;<span class="comment">//获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseData</span><span class="params">(data: Data)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Dictionary</span>&gt;<span class="comment">//解析数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saveData</span><span class="params">(diationary: Dictionary)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">String</span>&gt;<span class="comment">//保存数据</span></span><br></pre></td></tr></table></figure><p>我们以前常用的做法是if判断，肯定没问题，但是如果我们尝试用上面提到的函数式思想去考虑的话也许就有更好的方法。</p><p>下面是我自己写的常用的一个用以处理结果的类，并将<code>map</code>和<code>flatMap</code>的操作自定义成一个操作符，方便串连调用，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="comment">///This enumuration describes the result of all situation.</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> success(<span class="type">T</span>)</span><br><span class="line">    <span class="keyword">case</span> failure(<span class="type">Error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="comment">///Functor</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .success(<span class="keyword">let</span> v):</span><br><span class="line">            <span class="keyword">return</span> .success(transform(v))</span><br><span class="line">        <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">            <span class="keyword">return</span> .failure(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///Applicative</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">apply</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transform: Result&lt;<span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> transform &#123;</span><br><span class="line">        <span class="keyword">case</span> .success(<span class="keyword">let</span> function):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.<span class="built_in">map</span>(function)</span><br><span class="line">        <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">            <span class="keyword">return</span> .failure(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///Monad</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(T)</span></span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .success(<span class="keyword">let</span> v):</span><br><span class="line">            <span class="keyword">return</span> transform(v)</span><br><span class="line">        <span class="keyword">case</span> .failure(<span class="keyword">let</span> e):</span><br><span class="line">            <span class="keyword">return</span> .failure(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">precedencegroup <span class="type">ChainingPrecedence</span> &#123;</span><br><span class="line">    <span class="keyword">associativity</span>: <span class="keyword">left</span></span><br><span class="line">    higherThan: <span class="type">TernaryPrecedence</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///Functor</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &lt;^&gt;: <span class="type">ChainingPrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> &lt;^&gt;&lt;T, U&gt;<span class="params">(lhs: <span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>, rhs: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs.<span class="built_in">map</span>(lhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///Applicative</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &lt;*&gt;: <span class="type">ChainingPrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> &lt;*&gt;&lt;T, U&gt;<span class="params">(lhs: Result&lt;<span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>&gt;, rhs: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs.apply(lhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///Monad</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &gt;&gt;-: <span class="type">ChainingPrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> &gt;&gt;-&lt;T, U&gt;<span class="params">(lhs: Result&lt;T&gt;, rhs: <span class="params">(T)</span></span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.flatMap(rhs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那这个问题可以简单的这样处理 ，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = checkNet()&gt;&gt;-fetchData&gt;&gt;-parseData&gt;&gt;-saveData</span><br></pre></td></tr></table></figure><p>哪一个步骤出错了，错误信息也都能捕捉到，所以这样子是不是就是简单了好多，代码优雅了好多。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>swift</code> 是一门多编程范式语言，对于函数式编程的思想集成的很好，标准库已经实现了很多高阶函数，<code>FP</code>思想很多时候能在一些问题的处理上带给我们不同的思路和解决方法，希望以上的信息能够帮到你，谢谢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;flatMap&lt;/code&gt;是swift中两个高阶函数，用处很大，其实不仅仅是这两个函数，其他的譬如&lt;code&gt;reduce&lt;/code&gt;，&lt;code&gt;filter&lt;/code&gt;等等，都为我们提供了很多功能，是之前在oc里无法提
      
    
    </summary>
    
      <category term="swift" scheme="http://yoursite.com/categories/swift/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
      <category term="函数式编程" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>swift中的Initialization</title>
    <link href="http://yoursite.com/2017/07/04/swift%E4%B8%AD%E7%9A%84Initialization/"/>
    <id>http://yoursite.com/2017/07/04/swift中的Initialization/</id>
    <published>2017-07-04T08:34:49.000Z</published>
    <updated>2018-07-05T07:44:20.928Z</updated>
    
    <content type="html"><![CDATA[<p>本文相关知识参考了Apple官方的<a href="https://docs.swift.org/swift-book/LanguageGuide/Initialization.html" target="_blank" rel="noopener">Swift文档</a></p><p>Initialization也就是我们说的构造方法，class，struct，enumeration都会通过这个方法来构造一个自己的实例对象，并在这个过程中做一些必要的初始化。但是和Objective-C不一样的是，你会发现swift中的构造方法没有返回值。他们的主要作用就是保证一个类型的实例在被第一次使用前，能够被正确的构造出来，并初始化。class类型的实例还会有析构函数（Deinitialization）。我们还是通过<code>struct</code>和<code>class</code>具体来看一下他们的用法和原理吧。</p><h1 id="struct的Initialization"><a href="#struct的Initialization" class="headerlink" title="struct的Initialization"></a>struct的Initialization</h1><p>无论是struct还是class，他们的实例在被构造的过程中必须要保证所有的<code>stored properties</code>全都被初始化成功，也就是说所有的存储属性必须都有值，否者无法被正确构造。所以基于此，常规构造方法如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    name = <span class="string">"Peter"</span></span><br><span class="line">    age = <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> peopleOne = <span class="type">People</span>()<span class="comment">//name = peter, age = 18</span></span><br></pre></td></tr></table></figure><p>但是同样的，我们也可以为struct的存储属性设置默认值，这样它就能获得一个默认构造方法，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Peter"</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> peopleOne = <span class="type">People</span>()<span class="comment">//name = peter, age = 18</span></span><br></pre></td></tr></table></figure><p>但是很多时候为了更好的适用性，我们通常会自定义我们想要的构造方法，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">init</span>(personName name: <span class="type">String</span>, <span class="number">_</span> age: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> peopleOne = <span class="type">People</span>(personName: <span class="string">"Peter"</span>, <span class="number">18</span>)<span class="comment">//name = peter, age = 18</span></span><br></pre></td></tr></table></figure><p>上面构造方法中的<code>personName</code>叫做<code>Argument Label</code>是在构造方法被外部调用时使用的，而它后面的<code>name</code>叫做<code>Parameter Name</code>是在构造方法内部使用的，如果希望外部调用的时候简洁一些，不要<code>Argument Label</code>那就可以直接用<code>__</code>下划线替代。</p><h2 id="Memberwise-Initializers"><a href="#Memberwise-Initializers" class="headerlink" title="Memberwise Initializers"></a>Memberwise Initializers</h2><p>struct还有一个很特别的默认提供的构造方法，<code>Memberwise Initializers</code>，我们可以把它叫做逐一成员构造法，按照字面意思即可理解，就是将他的所有成员逐个全部赋值，只要struct没有自定义的构造方法，那么就会默认获得这个构造方法。用法如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> peopleOne = <span class="type">People</span>(ame: <span class="string">"Peter"</span>, age: <span class="number">18</span>)<span class="comment">//name = peter, age = 18</span></span><br></pre></td></tr></table></figure><h2 id="值类型的构造器代理"><a href="#值类型的构造器代理" class="headerlink" title="值类型的构造器代理"></a>值类型的构造器代理</h2><p>什么是构造器代理(Initializer Delegation)，值类型的构造器代理其实就是类型里面有不止一个构造方法，其中一个构造方法的实现里调用了本类型里的另一个构造方法，来避免一些重复的代码。class类型因为有继承的关系，构造器代理会复杂很多，我们下面会讲。直接看代码就明白了，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">init</span>(personName name: <span class="type">String</span>, <span class="number">_</span> age: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span>(info: (<span class="type">String</span>, <span class="type">Int</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> infoName = info.<span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> infoAge = info.<span class="number">1</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(personName: infoName, infoAge)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> peopleOne = <span class="type">People</span>(info: (<span class="string">"Peter"</span>, <span class="number">18</span>))<span class="comment">//name = peter, age = 18</span></span><br></pre></td></tr></table></figure><p>上面的代码，我们定义了另外一个构造器，入参是一个<code>(String, Int)</code>类型的<code>Tuple</code>，但是我们在它的实现里，通过代理给原有的构造方法来实现了完整构造，并节省了重复代码。</p><p><img src="https://i.loli.net/2018/07/05/5b3d85e43385a.jpg" alt="开心"></p><h1 id="class的Initialization"><a href="#class的Initialization" class="headerlink" title="class的Initialization"></a>class的Initialization</h1><p>类类型中的构造方法比起值类型来说，要复杂一些，因为它可以继承等，我们还是通过例子从最简单的开始说起，同样的，如果类里面给所有的存储属性提供了默认值，那么它可以获得一个默认的构造方法<code>init()</code>，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Peter"</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> personOne = <span class="type">Person</span>()<span class="comment">//name = Peter, age = 18</span></span><br></pre></td></tr></table></figure><h2 id="Designated-Initializer和Convenience-Initializer"><a href="#Designated-Initializer和Convenience-Initializer" class="headerlink" title="Designated Initializer和Convenience Initializer"></a>Designated Initializer和Convenience Initializer</h2><p>Designated Initializer我们直译为指定构造器，这是class类型里面的主要构造器，我们平时写的构造器基本都是Designated Initializer，来看例子，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Peter"</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这就是Designated Initializer</span></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> personOne = <span class="type">Person</span>(name: <span class="string">"Peter"</span>, age: <span class="number">18</span>)<span class="comment">//name = Peter, age = 18</span></span><br></pre></td></tr></table></figure><p>同时，类类型里面还有Convenience Initializer，我们直译为便利构造器，它只能横向代理，也就是说在它的实现里，最后必须调用本类里其他的指定构造器。便利构造器很多时候是为了一些特殊的场景，为了方便初始化而创造出来的，他的实现是基于某个指定构造器的，所以最终必须要调用某个指定构造器。我们看例子，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Peter"</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这就是Designated Initializer</span></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这就是Convenience Initializer</span></span><br><span class="line">  <span class="keyword">convenience</span> <span class="keyword">init</span>(info: (<span class="type">String</span>, <span class="type">Int</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> infoName = info.<span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> infoAge = info.<span class="number">1</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(name: infoName, age: infoAge)<span class="comment">//调用指定构造器</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> personOne = <span class="type">Person</span>(info: (<span class="string">"Peter"</span>, <span class="number">18</span>))<span class="comment">//name = Peter, age = 18</span></span><br></pre></td></tr></table></figure><h2 id="通过class的继承来看swift的two-phase-process"><a href="#通过class的继承来看swift的two-phase-process" class="headerlink" title="通过class的继承来看swift的two-phase process"></a>通过class的继承来看swift的two-phase process</h2><h3 id="继承和代理规则"><a href="#继承和代理规则" class="headerlink" title="继承和代理规则"></a>继承和代理规则</h3><p>上面我们看到了class类型的指定构造器和便利构造器，还是比较简单的，但是如果刚刚的<code>Person</code>的类型又派生出多个子类，有了继承，那就变得稍稍复杂了。我们还是来看一下吧，我们看例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Peter"</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这就是Designated Initializer</span></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这就是Convenience Initializer</span></span><br><span class="line">  <span class="keyword">convenience</span> <span class="keyword">init</span>(info: (<span class="type">String</span>, <span class="type">Int</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> infoName = info.<span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> infoAge = info.<span class="number">1</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(name: infoName, age: infoAge)<span class="comment">//调用指定构造器</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> studentNumber: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Student</code>继承自<code>Person</code>，<code>因为没有实现任何指定构造方法，所以自动继承父类Person的指定构造方法</code>，这是swift中继承规则的第一条，第二条是，<code>如果派生类实现了父类的所有指定构造方法，无论是规则一继承实现还是重载实现，那么可以继承父类的所有便利构造方法</code>。上面的例子中，<code>Student</code>满足了这两个条件，所以它继承了父类所有的指定和便利构造方法。我们来试试，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> studentOne = <span class="type">Student</span>(name: <span class="string">"Peter"</span>, age: <span class="number">18</span>)<span class="comment">//Student可以调用父类的指定构造器</span></span><br><span class="line"><span class="keyword">let</span> studentTwo = <span class="type">Student</span>(info: (<span class="string">"Jack"</span>, <span class="number">20</span>))<span class="comment">//Student可以调用父类的便利构造器</span></span><br></pre></td></tr></table></figure><p>当然，我们也可以不继承父类的指定构造器，我们可以直接重载它，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> studentNumber: <span class="type">Int</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//重载父类指定构造器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.studentNumber = <span class="number">0</span></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, age: age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，上面的初始化<code>studentOne</code>和<code>studentTwo</code>依然是可行的，它符合swift的两条继承规则。但是重载父类指定构造器必须调用父类的指定构造器，也就是上述代码中的<code>super.init(name: name, age: age)</code>，这个也就是我们所说的纵向代理。指定构造器只能纵向代理。</p><p>同时我们也可以重载父类的便利构造方法，但是不用写<code>override</code>关键字，原因是便利构造器只能横向代理，也就是只能代理给本类的指定构造器，实际上并没有调用父类的同名便利构造方法，严格意义上来讲，重载父类便利构造方法不能算作重载，所以也就不用<code>override</code>关键字了。来看代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> studentNumber: <span class="type">Int</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//重载父类指定构造器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.studentNumber = <span class="number">0</span></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, age: age)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//‘重载’父类便利构造器，严格意义上不能称之为重载</span></span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(info: (<span class="type">String</span>, <span class="type">Int</span>)) &#123;</span><br><span class="line">        <span class="keyword">let</span> infoName = info.<span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> infoAge = info.<span class="number">1</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: infoName, age: infoAge)</span><br><span class="line">        <span class="keyword">self</span>.studentNumber = <span class="number">8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，让我们少许总结一下吧</p><blockquote><p>class中的继承规则</p></blockquote><p>1.如果子类没有实现任何指定构造方法，那么该子类会自动继承父类的所有指定构造方法。</p><p>2.如果子类实现了父类的所有指定构造方法，无论是通过规则一继承的，还是通过重载实现的，那么子类可以继承父类的所有便利构造方法。</p><blockquote><p>class的构造方法的代理规则（我们可以简称为：指定构造器必须纵向代理，便利构造器必须横向代理）</p></blockquote><p>1.一个指定构造方法必须调用它直接父类的构造方法。</p><p>2.一个便利构造方法必须调用本类的其他构造方法。</p><p>3.一个便利构造方法无论调用本类多少构造方法，最终必须调用一个指定构造方法。</p><p>我们来看一张图，就十分清晰明了了，<code>指定构造器必须纵向代理，便利构造器必须横向代理</code>如下：</p><p><img src="https://res.cloudinary.com/petershi/image/upload/v1530774621/initializerDelegation02_2x.png" alt="代理规则"></p><h3 id="two-phase-process"><a href="#two-phase-process" class="headerlink" title="two-phase process"></a>two-phase process</h3><p>two-phase process，我直译为两段式构造过程。那什么叫两段式构造过程，其实就是swift把创建一个实例类的过程分成了两步。</p><blockquote><p>第一步</p></blockquote><ul><li><p>class中的一个指定构造器或便利构造器被调用</p></li><li><p>这个实例的内存被分配，但是该内存还没有被初始化</p></li><li><p>class中的指定构造器给class中的所有存储属性赋值，并且这些存储属性的内存被初始化</p></li><li><p>本类中的指定构造器调用父类的指定构造器，让父类完成和本类一样的工作初始化所有存储属性</p></li><li><p>顺着继承链一直到达最顶层的父类，完成同样的操作</p></li><li><p>当所有父类均对自有的存储属性完成初始化操作，保证了所有存储属性有值，那么该实例被完全初始化，第一步也就完成了</p></li></ul><blockquote><p>第二步</p></blockquote><ul><li><p>从继承链的最顶层逐步往下，没个指定构造器都有机会进一步定制实例对象，现在没个构造器里可是使用<code>self</code>来修改属性或者调用实例方法等</p></li><li><p>最终，在这条链中的便利构造器有机会去进一步自定义实例对象，并且可以使用<code>self</code>关键字</p></li></ul><p>所以还记得我们上面举过的一个例子吗，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> studentNumber: <span class="type">Int</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//重载父类指定构造器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.studentNumber = <span class="number">0</span></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, age: age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们把上述代码指定构造器里的<code>self.studentNumber = 0</code>和<code>super.init(name: name, age: age)</code>这两行对调可以吗？我们试一下，代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> studentNumber: <span class="type">Int</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//重载父类指定构造器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, age: age)<span class="comment">//Property 'self.studentNumber' not initialized at super.init call</span></span><br><span class="line">      <span class="keyword">self</span>.studentNumber = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会立马报错<code>Property &#39;self.studentNumber&#39; not initialized at super.init call</code>，为什么，因为在两段式构造过程中，第一步要求派生类必须自下而上的完成存储属性的初始化，所以上述代码必须先将本类的<code>studentNumber</code>先初始化，然后调用父类指定构造器，让父类做相同工作。</p><p>同样的，便利构造器也必须在最终调用完指定构造器后，才能使用<code>self</code>来自定义实例对象，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">convenience</span> <span class="keyword">init</span>(info: (<span class="type">String</span>, <span class="type">Int</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> infoName = info.<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> infoAge = info.<span class="number">1</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(name: infoName, age: infoAge)<span class="comment">//必须先调用完指定构造器</span></span><br><span class="line">    <span class="keyword">self</span>.studentNumber = <span class="number">8</span><span class="comment">//然后才能自己自定义实例对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>struct和class的init构造方法是我们很常用的方法，不过里面也有非常多的细节和注意的地方，希望上述相关知识在你以后使用构造方法的时候能够帮上你的忙。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文相关知识参考了Apple官方的&lt;a href=&quot;https://docs.swift.org/swift-book/LanguageGuide/Initialization.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swift文档&lt;/a&gt;
      
    
    </summary>
    
      <category term="swift" scheme="http://yoursite.com/categories/swift/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>swift中closure捕获列表的研究</title>
    <link href="http://yoursite.com/2017/06/09/swift%E4%B8%ADclosure%E6%8D%95%E8%8E%B7%E5%88%97%E8%A1%A8%E7%9A%84%E7%A0%94%E7%A9%B6/"/>
    <id>http://yoursite.com/2017/06/09/swift中closure捕获列表的研究/</id>
    <published>2017-06-09T06:24:14.000Z</published>
    <updated>2018-07-09T08:55:58.542Z</updated>
    
    <content type="html"><![CDATA[<p>本文相关知识参考了<a href="https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html#ID56" target="_blank" rel="noopener">Apple官方文档</a>，<a href="https://www.boxueio.com/series/understand-ref-types/episode/185" target="_blank" rel="noopener">泊学网</a></p><p>其实closure并不是什么新东西，如果你是从<code>Objective-C</code>转为<code>swift</code>开发的，那你可以很容易的理解它，它就相当于oc里的block，在swift里，我们称之为闭包(closure)。所谓循环引用，其实和oc一样，也就是对象之间的互相持有，造成互相都释放不了的情况。在siwft中我们可以通过捕捉列表(capture list)来解决它。我们一起通过几个例子来了解它们吧。</p><h1 id="closure捕获的含义"><a href="#closure捕获的含义" class="headerlink" title="closure捕获的含义"></a>closure捕获的含义</h1><p>如果我们粗略看过一遍Apple官方文档，或者以前做过oc开发，就很清楚闭包能够捕获其中的变量，但是呢，在swift中如果使用捕获列表，其实捕获的含义就变了，我们通过例子来具体看一下。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//值类型捕捉</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> closureOne = &#123;<span class="built_in">print</span>(a)&#125;</span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">closureOne()<span class="comment">//打印2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引用类型捕捉</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"--"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="type">Person</span>()</span><br><span class="line"><span class="keyword">var</span> closureTwo = &#123;<span class="built_in">print</span>(person.name)&#125;</span><br><span class="line"></span><br><span class="line">closureTwo()<span class="comment">//打印--</span></span><br><span class="line">person = <span class="type">Person</span>()</span><br><span class="line">person.name = <span class="string">"Peter"</span></span><br><span class="line">closureTwo()<span class="comment">//打印Peter</span></span><br></pre></td></tr></table></figure><p>我们会发现，无论是值类型还是引用类型的捕捉，当<code>a</code>和<code>person</code>这两个变量在被closure第一次捕捉后，然后我们改变这两个变量的值，给他们赋予新的值，我们再次执行之前的closure，会发现都是打印的新值，而不是第一次的旧值，所以我们得出一个重要结论：</p><p>1.<code>无论是值类型变量a，还是引用类型变量person，闭包都是捕获他们的引用，而不是他们引用的对象</code>。</p><p>2.<code>closure表达式的值在定义时不会被评估，直到调用的时候才会被评估</code></p><p>变量a在这边虽然是值类型，但是这边确实是引用语义。</p><p>是不是不太好理解，我们这样来理解比较好，在这边，我们可以将a和person这两个变量想象为容器，容器里面装着1，2，或者不同的person实例。在这边我们只是捕捉了对容器的引用，至于容器里装了什么，我们不关心，它会随着外面的赋值而改变。</p><p>如果我们现在使用了capture list呢，我们来看一下代码，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//值类型捕捉</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> closureOne = &#123;[a] <span class="keyword">in</span> <span class="built_in">print</span>(a)&#125;<span class="comment">//增加了捕捉列表</span></span><br><span class="line">closureOne()<span class="comment">//打印1</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line">closureOne()<span class="comment">//打印1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//引用类型捕捉</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"--"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="type">Person</span>()</span><br><span class="line"><span class="keyword">var</span> closureTwo = &#123;[person] <span class="keyword">in</span> <span class="built_in">print</span>(person.name)&#125;<span class="comment">//增加了捕捉列表</span></span><br><span class="line"></span><br><span class="line">person = <span class="type">Person</span>()</span><br><span class="line">person.name = <span class="string">"Peter"</span></span><br><span class="line">closureTwo()<span class="comment">//打印--</span></span><br></pre></td></tr></table></figure><p>看上述代码，一旦我们使用了捕捉列表，我们会发现，无论变量a还是变量person，都是打印第一次的值，后续对这两个变量的更改，对closure的捕捉已经没有影响了。至此，我们可以得出另外一个重要结论：</p><p>1.<code>在闭包内部，一旦使用capture list，那么对变量的捕捉不再是引用语义的捕获，而是值语义的捕获，捕获的是他们引用的对象</code></p><p>2.<code>使用捕获列表后，在闭包的定义阶段，就已经捕获了变量</code></p><h1 id="使用捕获列表解决循环引用的问题"><a href="#使用捕获列表解决循环引用的问题" class="headerlink" title="使用捕获列表解决循环引用的问题"></a>使用捕获列表解决循环引用的问题</h1><p>在我们理解了捕获列表的真正含义之后，接下来我们就可以看一下捕获列表是如何解决循环引用问题的了。我们还是以例子来解释，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"Peter"</span></span><br><span class="line">    <span class="keyword">var</span> function: () -&gt; () = &#123;&#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Person deinit"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> person = <span class="type">Person</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//控制台最终打印“Person deinit”</span></span><br></pre></td></tr></table></figure><p>上面的代码绝对没有问题，控制台也打印了”Person deinit”，说明person本成功释放，如果我们加两行行代码，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"Peter"</span></span><br><span class="line">    <span class="keyword">var</span> function: () -&gt; () = &#123;&#125;</span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Person deinit"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> person = <span class="type">Person</span>()</span><br><span class="line">    person.function = &#123;<span class="built_in">print</span>(<span class="string">"My name is <span class="subst">\(person.name)</span>"</span>)&#125;</span><br><span class="line">  person.function()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//控制台打印“My name is Peter”</span></span><br><span class="line"><span class="comment">//但是控制台没有打印“Person deinit”，person无法释放</span></span><br></pre></td></tr></table></figure><p>很明显，上面的代码循环引用了，我们如何来处理它，首先，我们添加捕获列表，让闭包不再捕捉person的引用，而是捕获person引用的对象，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> person = <span class="type">Person</span>()</span><br><span class="line">    person.function = &#123;[person] <span class="keyword">in</span> <span class="built_in">print</span>(<span class="string">"My name is <span class="subst">\(person.name)</span>"</span>)&#125;</span><br><span class="line">  person.function()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//控制台打印“My name is Peter”</span></span><br><span class="line"><span class="comment">//但是控制台没有打印“Person deinit”，person无法释放</span></span><br></pre></td></tr></table></figure><p>但是这样的话，在闭包内，我们捕获到了person具体引用的对象，可是它引用的对象还是个引用类型，所以还是有循环引用，不过现在问题就熟悉多了，就变成了我们熟悉的类似类与类之间的循环引用一样，所以我们需要添加关键字<code>unowned</code>，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">true</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> person = <span class="type">Person</span>()</span><br><span class="line">    person.function = &#123;[<span class="keyword">unowned</span> person] <span class="keyword">in</span> <span class="built_in">print</span>(<span class="string">"My name is <span class="subst">\(person.name)</span>"</span>)&#125;</span><br><span class="line">  person.function()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//控制台打印“My name is Peter”</span></span><br><span class="line"><span class="comment">//同时控制台也打印“Person deinit”，person成功释放</span></span><br></pre></td></tr></table></figure><p>其实很简单，就和类与类之间的循环引用一样，我们只需要打破这个引用环即可。不过这边使用<code>unowned</code>是因为被捕获的person变量对象和这个闭包的生命周期是一致的，所以用<code>unowned</code>，如果在这个closure的生命周期中，这个被捕获的person对象有可能为nil，那么就需要使用<code>weak</code>关键字来修饰了。这个很重要，如果用错有时会发生意想不到的错误。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>闭包在swift中用的非常多，特别是如果我们以函数式思想来设计一些代码，或多或少我们会遇到一些情况会发生循环引用，如果我们能够清楚闭包如何捕获变量，清楚捕获列表如何捕获变量，那么我们出现循环引用bug的机率就会小很多，希望上面的相关只是能够帮到你。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文相关知识参考了&lt;a href=&quot;https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html#ID56&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ap
      
    
    </summary>
    
      <category term="swift" scheme="http://yoursite.com/categories/swift/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>ios中UIScrollView的基础知识</title>
    <link href="http://yoursite.com/2017/01/24/ios%E4%B8%ADUIScrollView%E7%9A%84%E7%94%A8%E6%B3%95/"/>
    <id>http://yoursite.com/2017/01/24/ios中UIScrollView的用法/</id>
    <published>2017-01-24T01:52:49.000Z</published>
    <updated>2018-08-01T09:21:43.648Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容参考了<a href="https://developer.apple.com/documentation/uikit/uiscrollview" target="_blank" rel="noopener">Apple官方文档</a></p><p>无论学什么知识，我觉得最开始最重要的还是学这个东西的概念，然后再是他的用法，最后才是自己的拓展和对其思考。对于iOS知识也一样，所以我们可以通过Apple的官方文档来看看一些概念和用法。很多年以前自己初入iOS编程的时候，也是项目用到什么就学什么，可是现在我总觉得有必要重读一些Apple的文档，把一些基础的概念弄清楚，所以也想把这些记录在此，方便自己以后的温故而知新，也方便其他有需要的同学。以下内容翻译自<a href="https://developer.apple.com/documentation/uikit/uiscrollview" target="_blank" rel="noopener">Apple官方文档</a>，并根据自己的理解做了些必要的补充，方便自己和他人的理解。</p><h1 id="UIScrollView介绍"><a href="#UIScrollView介绍" class="headerlink" title="UIScrollView介绍"></a>UIScrollView介绍</h1><p>总体而言，UIScrollView就是一个可以滚动其包含的子视图，也可以放大缩小其包含的子视图的视图。</p><p>UIScrollView是好几个UIKit类的父类，譬如UITableView，UITextView。</p><p>UIScrollView的主要特性就是他内容的起点会根据他的内容视图随时调整。一般而言，通常都是以应用主窗口的大小来作为UIScrollView的大小（但这不是必须的，我们可随意调整大小）来裁剪他内部的内容视图，以此来显示内容。UIScrollView也会跟踪手指的移动并以此来调整内容视图的起点。内容视图会根据因为手指移动而偏移的新的起点来绘制UIScrollView可见部分的内容。UIScrollView本身并不绘制什么东西，除了展示垂直或水平滚动的指示器。UIScrollView必须知道内容视图的size，因为这样他才能知道什么时候该停止滚动。默认情况下，当滚动超过了内容视图的边界，它会自动反弹回来。</p><p>在UIScrollView里用来管理视图绘制和展示的对象，会将所有子视图铺在一起来保证没有视图会超出屏幕的尺寸。当用户用手指滚动的时候，这个对象会根据需要添加和移除对应的子视图，来保证UIScrollView显示图像的正确性。</p><p>因为UIScrollView不像电脑的图表一样，没有可操作的滚动条，所以他必须要知道一个触摸是否表示要滚动，还是表示跟踪对应的子视图。为了达到这个目的，它启动了一个计时器，并临时截获了touch-down事件，在计时器开始激活之前，会看一下被截获的触摸手指是否会有其他的移动。如果计时器被激活的时候，这个触摸手指没有有效的位置改变，UIScrollView会给被触摸的子视图发送跟踪事件。如果在计时器结束之前，用户手指拖动了足够远的距离，那么UIScrollView会取消任何对子视图的跟踪并且执行滚动操作。子类化UIScrollView，可以重载<a href="https://developer.apple.com/documentation/uikit/uiscrollview/1619418-touchesshouldbegin" target="_blank" rel="noopener"><code>touchesShouldBegin(_:with:in:)</code></a>,<a href="https://developer.apple.com/documentation/uikit/uiscrollview/1619432-ispagingenabled" target="_blank" rel="noopener"><code>isPagingEnabled</code></a>, 和<code>touchesShouldCancel(in:)</code>这几个方法来影响scroll view如何处理滚动手势。</p><p>UIScrollView也可以放大缩小以及平移它里面的内容视图。当用户使用一个pinch-in或者pinch-out手势的时候，scroll view会调整内容视图的偏移和放大缩小的比例。当手势结束的时候，管理内容视图的对象就会根据需要更新包含的子视图。当手势还在进行中的时候，scroll view不会对子视图发送任何跟踪消息。</p><p>UIScrollView类可以拥有一个代理，这个代理必须遵循UIScrollViewDelegate协议。为了使缩放以及平移操作都能顺利进行，代理必须实现<a href="https://developer.apple.com/documentation/uikit/uiscrollviewdelegate/1619426-viewforzooming" target="_blank" rel="noopener"><code>viewForZooming(in:)</code></a>和<code>scrollViewDidEndZooming(_:with:atScale:)</code>这两个方法。 除此之外, 缩放的最大比例和最小比例必须不一样。</p><h1 id="UIScrollView的属性和相关API"><a href="#UIScrollView的属性和相关API" class="headerlink" title="UIScrollView的属性和相关API"></a>UIScrollView的属性和相关API</h1><h2 id="响应scroll-view交互"><a href="#响应scroll-view交互" class="headerlink" title="响应scroll view交互"></a>响应scroll view交互</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> delegate: <span class="type">UIScrollViewDelegate</span>?</span><br></pre></td></tr></table></figure><p>scroll view的代理对象</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">UIScrollViewDelegate</span></span></span><br></pre></td></tr></table></figure><p>遵循了这个协议的对象就是UIScrollView的代理对象，可以通过实现这个协议里方法来自定义很多UIScrollView的操作，譬如滚动，放大缩小，滚动动画等等</p><h2 id="管理内容尺寸和偏移"><a href="#管理内容尺寸和偏移" class="headerlink" title="管理内容尺寸和偏移"></a>管理内容尺寸和偏移</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> contentSize: <span class="type">CGSize</span></span><br></pre></td></tr></table></figure><p>整个scroll view内容视图的尺寸,默认是(0,0)。其实就是scroll view可以滚动范围的大小，如果这个范围不大于scroll view的frame，那么scroll view 就不能滚动，contentSize必须大于scroll view的frame才可以滚动。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> contentOffset: <span class="type">CGPoint</span></span><br></pre></td></tr></table></figure><p>当前内容视图的起点相对于整个scroll view的起点的偏移量，x轴方向的偏移以及y轴方向的偏移。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setContentOffset</span><span class="params">(CGPoint, animated: Bool)</span></span></span><br></pre></td></tr></table></figure><p>通过这个方法可以主动设置contentOffset，并且可以用动画来展示这个转变。譬如你希望在展示scroll view的时候内容视图不在默认的起点，而是希望已经往下滚动了100，那么我们可以用这个函数来设置一个y轴方向的偏移量，并可以用动画展示它。</p><h2 id="管理内容嵌入的行为"><a href="#管理内容嵌入的行为" class="headerlink" title="管理内容嵌入的行为"></a>管理内容嵌入的行为</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> adjustedContentInset: <span class="type">UIEdgeInsets</span>&#123;<span class="keyword">get</span>&#125;</span><br></pre></td></tr></table></figure><p>这是一个只读属性，用来获取被调整后绘制内容视图的区域，可以理解为内容视图距离scroll view四周边界的距离，可以使用<code>contentInsetAdjustmentBehavior</code>这个属性来决定被调整的区域是否包含安全区域的inset。如果包含了，那么安全区域的inset会被自动加入到<code>contentInset</code>这个属性中，并且由<code>adjustedContentInset</code>获得最终的值</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> contentInset: <span class="type">UIEdgeInsets</span></span><br></pre></td></tr></table></figure><p>用户自定义的内容视图和安全区域或者scroll view边界之间的距离。默认的上下左右距离都是0，但是我们可以用它来扩展我们的内容视图和scroll view或者安全区域之间上下左右的间隔。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> contentInsetAdjustmentBehavior: <span class="type">UIScrollView</span>.<span class="type">ContentInsetAdjustmentBehavior</span></span><br></pre></td></tr></table></figure><p>这个属性会指定安全区域的inset会如何被用来影响内容视图的inset，默认值是<code>ContentInsetAdjustmentBehavior.automatic</code>，自动调整scroll view内容视图的insets。它还有其他几个枚举，如下：</p><p><code>scrollableAxes</code>：只在可滚动的方向调整insets</p><p><code>never</code>：从不调整scroll view的insets</p><p><code>always</code>：在内容视图的调整中总是包含安全区域的insets</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adjustedContentinsetDidChange</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>调整后的内容视图的insets如果发生改变，那么这个方法就会被调起。</p><h2 id="获取布局指南"><a href="#获取布局指南" class="headerlink" title="获取布局指南"></a>获取布局指南</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> frameLayoutGuide: <span class="type">UILayoutGuide</span>&#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><p>这是个只读属性，当我们想要明确的使用相对于scroll view本身，而不是相对于他的内容视图的布局约束的时候，我们就要使用这个属性来进行auto layout的约束设置。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> contentLayoutGuide: <span class="type">UILayoutGuide</span>&#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><p>和上面的属性一样，这也是一个只读属性，不过区别在于，当你想要相对于scroll view的内容视图做auto layout约束布局的时候，就要用这个属性来设置。</p><h2 id="对scrollVIew的配置构造"><a href="#对scrollVIew的配置构造" class="headerlink" title="对scrollVIew的配置构造"></a>对scrollVIew的配置构造</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isScrollEnabled: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>这是一个布尔值属性，用来决定scrollView是否可以滚动，默认是true。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isDirectionalLockEnabled: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>这是一个布尔值属性，默认值为false，用来决定用户拖拽的时候，scrollView是否在指定的方向不能滚动，也就是只能在一个方向拖拽。当值为false的时候，在水平和垂直方向都可以滚动；当值为true，并且用户在某一方向（水平或垂直）拖拽的时候，那么scroll view在另一方向就不能滚动了。如果用户拖拽的方向是斜的，那么滚动方向就不会被锁定，用户可以在任何方向拖拽直到拖拽完成。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isPagingEnabled: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>这是一个布尔值属性，用来决定scrollView的滚动是否是按页滚动，默认是false。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scrollsToTop: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>布尔值属性，用来决定滚动到顶部的手势是否可用。Apple自带的用手指点击status bar的手势就是将scroll view自动滚动到顶部。默认值true，自动打开这个手势的。如果设为false，那么scroll view 的代理方法<code>scrollViewShouldScrollToTop(_:)</code>会返回false，或者内容本身已经在顶部了，那就什么都不回发生。</p><p>在滚动到顶部后，代理方法<code>scrollViewDidScrollToTop(_:)</code>就会被调用。</p><p>在Iphone上，如果屏幕上有多于一个的scroll view，那么这个手势就不起作用了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bounces: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>布尔值属性，用来控制当scroll view滚动超过了内容视图的边界的时候，是否会自动弹回。默认值是true，用户可以滚动使scroll view 超出内容视图的边界，但是放手后会自动弹回。如果false，那么当滚动到边界的时候，就会立马停止滚动，无法超出边界，更不会弹回。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> alwaysBounceVertical: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>布尔值属性，用来决定当垂直方向滚动到内容结尾的时候，是否一直可以发生弹回。默认值是false，如果设为true，并且<code>bounces</code>属性也为true，那么垂直方向的拖拽总能发生弹回，即便内容视图的尺寸小于scroll view的边界。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> alwaysBounceHorizontal: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>布尔值属性，用来决定当水平方向滚动到内容结尾的时候，是否一直可以发生弹回。默认值是false，如果设为true，并且<code>bounces</code>属性也为true，那么水平方向的拖拽总能发生弹回，即便内容视图的尺寸小于scroll view的边界。</p><h2 id="获取滚动状态"><a href="#获取滚动状态" class="headerlink" title="获取滚动状态"></a>获取滚动状态</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isTracking: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><p>布尔值只读属性，用来告知用户是否开始触摸内容并准备开始滚动。返回值为true，表明用户已经触摸了内容，但可能还没有开始拖拽，但已经准备开始滚动了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isDragging: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><p>布尔值只读属性，用来表明用户是否已经开始拖拽滚动内容。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isDecelerating: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>布尔值只读属性，用来反馈当用户举起手指的时候，内容视图是否依然在滚动。当用户用手指在scroll view上拖拽了一下，然后手指离开屏幕，然后scroll view依然在减速滚动的时候，那么这个属性就会返回true。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> decelerationRate: <span class="type">UIScrollView</span>.<span class="type">DecelerationRate</span> &#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;</span><br></pre></td></tr></table></figure><p>float类型的值，用来决定当用户滑动离开后，scroll view 减速的速率。在iOS12中，可以用两个常量<code>normal</code>和<code>fast</code>来决定它的速率。</p><h2 id="管理滚动指示器和刷新控制"><a href="#管理滚动指示器和刷新控制" class="headerlink" title="管理滚动指示器和刷新控制"></a>管理滚动指示器和刷新控制</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> indicatorStyle: <span class="type">UIScrollView</span>.<span class="type">IndicatorStyle</span></span><br></pre></td></tr></table></figure><p>滚动指示器的样式，默认是是<code>UIScrollView.IndicatorStyle.default</code>，还有<code>black</code>和<code>white</code>的选项。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scrollIndicatorInsets: <span class="type">UIEdgeInsets</span>&#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure><p>滚动指示器距离scroll view边界的距离，默认都是<code>UIEdgeInsetsZero</code>，就是都是0。这个属性主要用来自定义滚动指示器的位置。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> showsHorizontalScrollIndicator: <span class="type">Bool</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure><p>布尔值属性，用来控制水平方向的滚动指示器是否显示，默认值是true。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> showsVerticalScrollIndicator: <span class="type">Bool</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure><p>布尔值属性，用来控制垂直方向的滚动指示器是否显示，默认值是true。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flashScrollIndicators</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>当你想要立马显示你的滚动指示器的时候，就调用这个方法，滚动指示器会显示了一下后，然后慢慢消失。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> refreshControl: <span class="type">UIRefreshControl</span>?&#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure><p>从iOS10以后，UIScrollView也拥有了refreshControl。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scrollRectToVisible</span><span class="params">(CGRect, animated: Bool)</span></span></span><br></pre></td></tr></table></figure><p>滚动到内容视图中的一个指定区域，让它刚刚好可以在屏幕的可见范围内。如果这个指定的区域已经在可见范围内了，那这个方法不会做任何事情。</p><h2 id="管理触摸"><a href="#管理触摸" class="headerlink" title="管理触摸"></a>管理触摸</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">touchesShouldBegin</span><span class="params">(<span class="number">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?, <span class="keyword">in</span> view: UIView)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>当一个手指触摸按下内容视图的时候，如果你想自定义一些默认行为，那么你就需要子类化UIScrollView，并重载这个方法。如果你不希望scroll view把事件消息传递给对应的view，那就返回false，不然就返回true。UIScrollView的默认行为是调用对应subview的UIResponder的事件处理方法来处理。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">touchesShouldCancel</span><span class="params">(<span class="keyword">in</span> view: UIView)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>当scroll view开始对内容视图发送跟踪消息之后，这个方法会被调用。如果返回false，scroll view会停止拖拽并且将触摸事件往前传递给对应的subview。如果返回true，那么就是取消更深层次的消息传递。如果触摸的view不是<code>UIControl</code>对象，那么默认返回值是true，否则默认返回值是false。如果<code>CanCancelContentTouches</code>这个属性是false，那么scroll view 就不会调用这个方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canCancelContentTouches: <span class="type">Bool</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure><p>布尔值属性，用来控制在内容视图上的触摸是否总是一个消息追踪。</p><p>如果这个值是true并且一个子视图已经开始追踪一个触摸它的手指了，并且这个时候用户拖拽这个手指足够长的距离，这个距离完全可以形成一次滚动，这个view会收到一个<code>touchesCancelled(_:with:)</code>消息，然后scroll view会将这个触摸处理为滚动而不是追踪。如果这个值是false，那么内容视图里的子视图只要开始了追踪，不管手指如何移动，scroll view都不会滚动。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> delaysContentTouches: <span class="type">Bool</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure><p>布尔值属性，用来决定scroll view 是否延迟处理touch-down手势。</p><p>如果这个属性是true，那么scroll view会延迟处理touch-down手势，直到可以确定这个手势的意图就是滚动。如果false，那么scroll view认为这是追踪意图，scroll view 会立即调用<code>touchesShouldBegin(_:with:in:)</code>。默认值是true。</p><h2 id="缩放和平移"><a href="#缩放和平移" class="headerlink" title="缩放和平移"></a>缩放和平移</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> panGestureRecognizer: <span class="type">UIPanGestureRecognizer</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><p>只读属性，平移手势识别器。如果我们需要更精确的平移手势操作，我们就需要用到这个属性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pinchGestureRecognizer: <span class="type">UIPinchGestureRecognizer</span>? &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><p>只读属性，捏合手势识别器。如果我们需要更精确的捏合手势操作，我们就需要用到这个属性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zoom</span><span class="params">(to rect: CGRect, animated: Bool)</span></span></span><br></pre></td></tr></table></figure><p>缩放内容视图到一个指定大小的区域，好让它在设备上可见。这个方法会将内容视图缩放到指定的rect，并且会根据需要自动调整zoomScale。在实现相应的代理方法后，可通过这个函数来进行缩放。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> zoomScale: <span class="type">CGFloat</span> &#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;</span><br></pre></td></tr></table></figure><p>float类型属性，用来指定当前scroll view的缩放系数。默认值是1.0</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setZoomScale</span><span class="params">(<span class="number">_</span> scale: CGFloat, animated: Bool)</span></span></span><br></pre></td></tr></table></figure><p>设置新的缩放系数，并可以选择用动画来执行这个改变。也是在实现相应的代理方法后，可通过这个函数来进行缩放。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maximumZoomScale: <span class="type">CGFloat</span> &#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;</span><br></pre></td></tr></table></figure><p>用于缩放的最大系数，决定了内容视图可以被放大到多大，如果可以缩放，那么这个值必须比minimum zoom scale大。默认值是1.0</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minimumZoomScale: <span class="type">CGFloat</span> &#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;</span><br></pre></td></tr></table></figure><p>用于缩放的最小系数，决定了内容视图可以被缩小到多小，如果可以缩放。默认值是1.0</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isZoomBouncing: <span class="type">Bool</span>&#123;<span class="keyword">get</span>&#125;</span><br></pre></td></tr></table></figure><p>布尔值只读属性，用来表示缩放已经超出了设定的最大或最小的限制。如果scroll view已经缩放到最大或最小，那么会被弹回到设定的最大和最小系数，这个时候返回true，否则返回false。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bouncesZoom: <span class="type">Bool</span>&#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;</span><br></pre></td></tr></table></figure><p>布尔值属性，用来决定当scroll view缩放超出最大或最小限制后，是否展示弹回的动画。如果是true，那么当缩放超出最大或最小限制后，scroll view 会临时用动画展示超出限制的缩放，如果松开手指，那么会展示退回到限制的最大或最小缩放系数的弹回动画。如果这个值是false，那么当scroll view被缩放到最大或最小限定系数后，会立即停止缩放，也不会有动画。默认值是true。</p><h2 id="管理键盘"><a href="#管理键盘" class="headerlink" title="管理键盘"></a>管理键盘</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keyboardDismissMode: <span class="type">UIScrollView</span>.<span class="type">KeyboardDismissMode</span>&#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;</span><br></pre></td></tr></table></figure><p>当一个拖拽在scroll view 上发生时，键盘消失的方式。这是一个枚举类型。</p><p><code>none</code>：当一个拖拽发生时，键盘不消失</p><p><code>onDrag</code>：当一个拖拽发生时，键盘消失</p><p><code>interactive</code>：交互型，键盘在拖拽触离开屏幕之后，也会消失，但可以再次向上拉，以取消关闭。</p><h2 id="管理索引"><a href="#管理索引" class="headerlink" title="管理索引"></a>管理索引</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> indexDisplayMode: <span class="type">UIScrollView</span>.<span class="type">IndexDisplayMode</span>&#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;</span><br></pre></td></tr></table></figure><p>当用户在滚动的时候，索引显示的方式。这是一个枚举值。</p><p><code>automatic</code>：索引的显示与否会根据适当的情况，自动决定。</p><p><code>alwayshidden</code>:索引不显示</p><h1 id="UIScrollViewDelegate相关基础知识"><a href="#UIScrollViewDelegate相关基础知识" class="headerlink" title="UIScrollViewDelegate相关基础知识"></a>UIScrollViewDelegate相关基础知识</h1><p>UIScrollViewDelegate这个协议所定义的方法允许遵守此协议的对象响应UIScrollView的一些消息，以此来响应并影响一些操作，譬如滚动，缩放，减速滚动内容还有滚动动画等。</p><h2 id="响应滚动和拖拽"><a href="#响应滚动和拖拽" class="headerlink" title="响应滚动和拖拽"></a>响应滚动和拖拽</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidScroll</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span></span><br></pre></td></tr></table></figure><p>当用户在滚动内容视图的时候，如果实现了这个方法，这个方法会被调用来告知代理对象，用户在滚动视图了。比较代表性的用法是，代理对象实现这个方法用来获得content offset的变化，然后绘制内容视图受影响的部分。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewWillBeginDragging</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span></span><br></pre></td></tr></table></figure><p>当scroll view将要开始拖拽滚动的时候，会告诉代理对象。代理对象可能直到拖拽发生了一小段距离才会收到这个消息。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewWillEndDragging</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer&lt;CGPoint&gt;)</span></span></span><br></pre></td></tr></table></figure><p>当用户将要完成拖拽滚动的时候告诉代理对象。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">option <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidEndDragging</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView, willDecelerate decelerate: Bool)</span></span></span><br></pre></td></tr></table></figure><p>当拖拽结束的时候告诉代理对象。这个方法在上面的方法之后被调用，当用户的手指在拖拽后离开屏幕的时候，scroll view会发送这个消息给代理对象。<code>willDecelerate</code>如果是true，说明还在滚动，但是在减速。如果是false，scroll view在手指离开后会立即停止滚动。之前介绍的<code>isDecelerating</code>这个属性能够控制scroll view是否减速。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewShouldScrollToTop</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>询问代理对象，scroll view是否可以滚到内容顶部。返回true，表明允许，false则不允许。</p><p>如果代理对象没有实现这个方法，那么系统默认是允许的。如果要让点击satus bar返回顶部的手势有效果，<code>scrollsToTop</code>这个属性必须被设置为yes。如果这个方法返回false，那么即便属性<code>scrollsToTop</code>是true，也不会有效果。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidScrollToTop</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span></span><br></pre></td></tr></table></figure><p>当scroll view已经滚动到内容顶部的时候，会立即向代理发送这个消息。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewWillBeginDecelerating</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span></span><br></pre></td></tr></table></figure><p>当scroll view将要开始减速滚动动作的时候，会告诉代理对象。scroll view在用户手指抬起，但scroll view依然在滚动的时候，会调用这个代理方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidEndDecelerating</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span></span><br></pre></td></tr></table></figure><p>当scroll view将滚动动作减速到停止后，会告诉代理对象。</p><h2 id="管理缩放"><a href="#管理缩放" class="headerlink" title="管理缩放"></a>管理缩放</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">viewForZooming</span><span class="params">(<span class="keyword">in</span> scrollView: UIScrollView)</span></span> -&gt; <span class="type">UIView</span>?</span><br></pre></td></tr></table></figure><p>当scroll view发生缩放的时候，scroll view会通过这个方法询问代理对象需要缩放的是哪一个view。如果你不想缩放有效果，可以返回nil。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewWillBeginZooming</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView, with view:UIView?)</span></span></span><br></pre></td></tr></table></figure><p>当在scroll view里内容视图缩放将要开始的时候，会通过这个方法告诉代理对象。这个方法在缩放手势开始的时候，或者通过缩放比例改变而实现动画的时候都会被调用。我们可以用这个方法，在缩放内容之前，来存储一些状态信息或者执行一些额外操作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidEndZooming</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView, with view: UIView?, atScale scale: CGFloat)</span></span></span><br></pre></td></tr></table></figure><p>当scroll view里的内容视图完成缩放的时候，会通过这个方法告诉代理对象。scroll view在任何弹回动画之后，或者改变缩放比例来实现动画之后，或者任何缩放相关的手势结束之后，都会调用这个方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidZoom</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span></span><br></pre></td></tr></table></figure><p>当scroll view的缩放系数改变的时候，也就是正在缩放的时候，会通过这个方法告诉代理对象。</p><h2 id="响应滚动动画"><a href="#响应滚动动画" class="headerlink" title="响应滚动动画"></a>响应滚动动画</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidEndScrollingAnimation</span><span class="params">(<span class="number">_</span> scrollView)</span></span></span><br></pre></td></tr></table></figure><p>当一个滚动动画结束的时候，会通过这个方法告诉代理对象。当用户执行了<code>setContentOffset(_:animated:)</code>或者<code>scrollRectToVisible(_:animated:)</code>方法后，并且他们的动画都是开着的时候，那么等他们的滚动动画结束的时候，就会调用本方法来通知代理对象。</p><h2 id="响应Inset的改变"><a href="#响应Inset的改变" class="headerlink" title="响应Inset的改变"></a>响应Inset的改变</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidChangeAdjustedContentInset</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span></span><br></pre></td></tr></table></figure><p>当scroll view的内嵌数值（inset value）发生改变的时候，会通过这个方法通知代理对象。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文内容参考了&lt;a href=&quot;https://developer.apple.com/documentation/uikit/uiscrollview&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Apple官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;无论学什么知识
      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
      <category term="iOS" scheme="http://yoursite.com/tags/iOS/"/>
    
  </entry>
  
</feed>
