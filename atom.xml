<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Uncle Peter</title>
  
  <subtitle>无他,但手熟尔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-02T12:19:39.653Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Uncle Peter</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>swift中copy on write的研究</title>
    <link href="http://yoursite.com/2018/03/05/swift%E4%B8%ADcopy%20on%20write%E7%9A%84%E7%A0%94%E7%A9%B6/"/>
    <id>http://yoursite.com/2018/03/05/swift中copy on write的研究/</id>
    <published>2018-03-05T02:19:49.000Z</published>
    <updated>2018-07-02T12:19:39.653Z</updated>
    
    <content type="html"><![CDATA[<p>本文部分相关知识参考了《Advanced Swift》以及<a href="https://www.boxueio.com" target="_blank" rel="noopener">泊学网</a></p><h1 id="什么是写时复制-copy-on-write"><a href="#什么是写时复制-copy-on-write" class="headerlink" title="什么是写时复制(copy-on-write)"></a>什么是写时复制(copy-on-write)</h1><p>在<code>swift</code>标准库中，像<code>Array</code>,<code>Dictionary</code>,<code>Set</code>这些结构体都实现了写时复制技术，那到底什么是写时复制呢？我们看一个例子就明白了，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> b = a</span><br></pre></td></tr></table></figure><p>如上面的代码所示，我们创建了一个数组<code>a</code>，同时我们将<code>a</code>赋给<code>b</code>，这是很常见的操作，其实这个时候，a和b是两个独立的值，但是在内部，a和b都是指向内存中同一个位置的引用，其实这两个数组共享了他们的存储部分，也就是说在堆内存中只有一份这样的数据，但是a和b都引用了这份数据。如果我们再增加一个操作，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.append(<span class="number">4</span>)<span class="comment">//[1,2,3,4]</span></span><br><span class="line">b<span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure><p>在这种时候，<code>swift</code>就会对内存进行复制，然后在复制的值上进行处理，从而不影响原来的那份值，也就是说只在必要的时候去复制。</p><p>总结一下就是：每当值类型内容发生变化时，它会首先检查对存储缓冲区的引用是否唯一，如果只有自己一个引用，那就在这份存储数据上原地修改即可，不会有复制发生。如果发现对存储缓冲区有不止一个引用，例如上面的例子，那么就会先进行复制，然后对复制的值进行操作，以免影响其他引用。总之只在必要时复制，否则不会复制。</p><p>在标准库中的集合类型，譬如<code>Array</code>,<code>Dictionary</code>,<code>Set</code>这些结构体都实现了写时复制技术，我们只管使用即可，它保持了值语义，同时也优化了性能，避免了昂贵的不必要的复制操作，但是这个福利并不是所有值类型都有，当我们自己创建一些值类型的时候，特别是我们自定义的值类型里包含引用类型对象时，为了保持值语义，我们就得自己来实现<code>copy-on-write</code>了。</p><h1 id="我们自己动手来实现COW"><a href="#我们自己动手来实现COW" class="headerlink" title="我们自己动手来实现COW"></a>我们自己动手来实现COW</h1><h2 id="一个比较粗糙的copy-on-write实现"><a href="#一个比较粗糙的copy-on-write实现" class="headerlink" title="一个比较粗糙的copy-on-write实现"></a>一个比较粗糙的copy-on-write实现</h2><p>譬如我们来实现一个我们自定义的<code>Array</code>，里面用来存储数据的是一个oc对象，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> elements: <span class="type">NSMutableArray</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> elements: <span class="type">NSMutableArray</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.elements = elements.mutableCopy() <span class="keyword">as</span>! <span class="type">NSMutableArray</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了实现值语义，我们将传入的elements复制一份，赋给内部的elements变量。同时，为了在操作<code>CustomArray</code>对象时隐藏<code>elements</code>属性，我们为它添加一个方法，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CustomArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> element: Any)</span></span> &#123;</span><br><span class="line">        elements.insert(element, at: elements.<span class="built_in">count</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们平常会写的代码，但是这样会有问题，看如下操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aArr = <span class="type">CustomArray</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> bArr = aArr</span><br><span class="line">aArr.append(<span class="number">4</span>)</span><br><span class="line">aArr.elements === bArr.elements<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><code>aArr</code>和<code>bArr</code>是两个独立的结构体，按照我们之前对copy-on-write的理解，当<code>aArr</code>内容发生变更时，会被复制一份，那么<code>aArr</code>和<code>bArr</code>将不再享有同一份内存数据，而是两份独立的数据，内存不再共享，但是上面的<code>aArr</code>和<code>bArr</code>中<code>elements</code>却仍旧是同一个引用对象，这个可以理解，因为我们没有对它做任何特殊处理，但是这样子却是不符合值语义的，所以为了保持值语义，我们需要来实现copy-on-write，我们来修改一下代码，我们创建一个计算属性<code>elementsCOW</code>，每当自定义数组需要改变内容时，我们都使用这个计算属性，来对内部的elements进行复制，然后使用这份拷贝来进行操作。相应的<code>append</code>方法都会使用这个计算属性，代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elementsCOW: <span class="type">NSMutableArray</span> &#123;</span><br><span class="line">        <span class="keyword">mutating</span> <span class="keyword">get</span> &#123;</span><br><span class="line">            elements = elements.mutableCopy() <span class="keyword">as</span>! <span class="type">NSMutableArray</span></span><br><span class="line">            <span class="keyword">return</span> elements</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CustomArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> element: Any)</span></span> &#123;</span><br><span class="line">        elementsCOW.insert(element, at: elementsCOW.<span class="built_in">count</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子的话，每次<code>append</code>新的元素，都会对内部<code>elements</code>进行拷贝后，使用拷贝的值进行添加操作，完全符合了值语义，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aArr = <span class="type">CustomArray</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> bArr = aArr</span><br><span class="line">aArr.append(<span class="number">4</span>)</span><br><span class="line">aArr.elements === bArr.elements<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>如果这样就完成了，那就太简单了，<img src="https://i.loli.net/2018/07/02/5b39fae014738.jpg" alt="5b39fae014738"></p><p>如果这样，我们确实为自定义的数组实现了值语义，每次使用修改时，都会复制一份，但是你会发现，如果这样，像上述的例子那样，如果没有<code>bArr</code>，只有一个<code>aArr</code>，我们每次都对<code>aArr</code>进行修改都会被复制一份，譬如这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> &#123;</span><br><span class="line">    aArr.append(i)<span class="comment">//aArr会被复制10次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的<code>aArr</code>会被复制10次，这样太不合理，内存明明只有一个引用，不会影响到其他对象使用，太浪费了。所以我们需要对上述代码在做一次更改，只在必要的时候复制。我们的思路是这样的，当值被更改时，判断对象是否只有一个引用，如果是，那就不复制，如果不是，那就需要复制一份。</p><h2 id="一个更高效的copy-on-write实现"><a href="#一个更高效的copy-on-write实现" class="headerlink" title="一个更高效的copy-on-write实现"></a>一个更高效的copy-on-write实现</h2><p>为此我们需要用到一个方法swift标准库中的<code>isKnownUniquelyReferenced</code>，对于Swift原生类对象，只有单一引用时返回<code>true</code>，否则返回<code>false</code>；对于Objective-C中的类对象，总是返回<code>false</code>，所以我们还不能直接用，我们需要把oc对象封装在swift对象之内，所以我们这样来做，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Pack</span>&lt;<span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> unpack: <span class="type">U</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> unpack: <span class="type">U</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.unpack = unpack</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们自定义一个类型<code>Pack</code>用来打包oc对象，使用<code>final</code>，不想让它被继承。然后我们可以修改一下上面的代码，内部元素<code>elements</code>可以打包，并且判断打包好后的swift类型是否只有唯一引用，不是的话就复制，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> elementsCOW: <span class="type">NSMutableArray</span> &#123;</span><br><span class="line">        <span class="keyword">mutating</span> <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> !isKnownUniquelyReferenced(&amp;elements) &#123;</span><br><span class="line">                elements = <span class="type">Pack</span>(elements.unpack.mutableCopy() <span class="keyword">as</span>! <span class="type">NSMutableArray</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"occur copy"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> elements.unpack</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> elements: <span class="type">Pack</span>&lt;<span class="type">NSMutableArray</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> elements: <span class="type">NSMutableArray</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.elements = <span class="type">Pack</span>(elements.mutableCopy() <span class="keyword">as</span>! <span class="type">NSMutableArray</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，再次执行原先的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> &#123;</span><br><span class="line">    aArr.append(i)<span class="comment">//aArr将不再被复制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，一个更加高效的写时复制完成了，它保证了我们自定义数组的值语义，并且只在必要的时候才去复制。</p><p><img src="https://i.loli.net/2018/07/02/5b3a1499291b6.jpg" alt="5b3a1499291b6"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在swift中，值类型是非常重要的类型，你会发现原来OC中是引用类型的数组，字典等在swift中都是值类型，因为更安全，高效。我们在自定义一些值类型时，为了维护值语义，通常都需要在每次变更时，都进行昂贵的复制操作，但是写时复制技术避免了在非必要的情况下的复制操作。希望以上这些可以帮到你。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文部分相关知识参考了《Advanced Swift》以及&lt;a href=&quot;https://www.boxueio.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;泊学网&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;什么是写时复制-copy-on-write&quot;&gt;
      
    
    </summary>
    
      <category term="swift" scheme="http://yoursite.com/categories/swift/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>swift中map与flatMap的用法与研究</title>
    <link href="http://yoursite.com/2018/02/26/swift%E4%B8%ADmap%E4%B8%8EflatMap%E7%9A%84%E7%94%A8%E6%B3%95%E4%B8%8E%E7%A0%94%E7%A9%B6/"/>
    <id>http://yoursite.com/2018/02/26/swift中map与flatMap的用法与研究/</id>
    <published>2018-02-26T02:19:49.000Z</published>
    <updated>2018-07-02T06:12:03.333Z</updated>
    
    <content type="html"><![CDATA[<p><code>map</code>和<code>flatMap</code>是swift中两个高阶函数，用处很大，其实不仅仅是这两个函数，其他的譬如<code>reduce</code>，<code>filter</code>等等，都为我们提供了很多功能，是之前在oc里无法提供，或者需要自己去实现的。当然这些函数在其他语言里是一直存在的，譬如<code>Haskell</code>。所以<code>swift</code>是一门多编程范式的语言，这里只是记录一下<code>map</code>和<code>flatMap</code>的用法，以及通过这个，我们来看一下函数式思想在<code>swfit</code>中的运用。</p><h1 id="map和flatMap用法"><a href="#map和flatMap用法" class="headerlink" title="map和flatMap用法"></a>map和flatMap用法</h1><p>我们直接看例子：</p><blockquote><p>例1  数组中使用</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.<span class="built_in">map</span> &#123;$<span class="number">0</span> + <span class="number">1</span>&#125;<span class="comment">//[2,3,4],将数组中每一个整数加一然后返回,返回值类型是Array</span></span><br><span class="line"><span class="keyword">let</span> arr3 = arr.flatMap &#123;[$<span class="number">0</span> - <span class="number">1</span>, $<span class="number">0</span> + <span class="number">1</span>]&#125;<span class="comment">//[0, 2, 1, 3, 2, 4]，将数组中每一个整型元素映射成了一个数组，如果用map将会得到一个二维数组，所以用flatmap降维成一维数组</span></span><br></pre></td></tr></table></figure><blockquote><p>例2  数组的<code>flatMap</code>(在swift4.1中，已经改名为compactMap,下面的源码也贴了出来)还有另外一种用法</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> brr = [<span class="string">"1"</span>, <span class="string">"2"</span>,<span class="string">"三"</span>, <span class="string">"4"</span>]</span><br><span class="line"><span class="comment">//let brr2 = brr.compactMap &#123;Int($0)&#125;</span></span><br><span class="line"><span class="keyword">let</span> brr2 = brr.flatMap &#123;<span class="type">Int</span>($<span class="number">0</span>)&#125;<span class="comment">//[1, 2, 4],Int()函数将String转成Int类型，有可能成功，也有可能失败，所以返回值类型是Optional&lt;Int&gt;,很明显这边数组brr里的"三"是无法成功转换成整型3的，所以返回nil，结果是[1,2,nil,4],此时的flatMap可以过滤掉了nil</span></span><br></pre></td></tr></table></figure><p>因为这个<code>flatMap</code>除了 降维之外其实还有 filter 的作用，在使用时容易产生歧义，所以社区认为最好把这个flatMap重新拆分出来，使用一个新的方法命名，所以就有了<code>compactMap</code>。</p><blockquote><p>例3  <code>optional</code>中使用</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str: <span class="type">String</span>? = <span class="string">"12"</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = str.<span class="built_in">map</span> &#123;$<span class="number">0</span>.<span class="built_in">count</span>&#125;<span class="comment">//count = 2,如果这个str有值，就计算这个string的字符个数，如果没有值，就返回nil，注意count的类型为Optional&lt;Int&gt;</span></span><br><span class="line"><span class="keyword">let</span> value = str.flatMap &#123;<span class="type">Int</span>($<span class="number">0</span>)&#125;<span class="comment">//value = 12,和上面数组中使用一样，Int()函数将String转成Int类型，有可能成功，也有可能失败，所以返回值类型是Optional&lt;Int&gt;，此时如果使用map，那么value返回的类型会变成Optional&lt;Optional&lt;Int&gt;&gt;，嵌套的optional，所以使用flatMap，其实也是降维的概念，使其返回类型变为Optional&lt;Int&gt;。</span></span><br></pre></td></tr></table></figure><h1 id="map和flatMap在标准库中的实现"><a href="#map和flatMap在标准库中的实现" class="headerlink" title="map和flatMap在标准库中的实现"></a>map和flatMap在标准库中的实现</h1><p>没有什么比看源码更能直接了当的了解一个类或者方法了，大家也可以直接去<a href="https://github.com/apple/swift/tree/master/stdlib/public/core" target="_blank" rel="noopener">swift源码</a>查看。我们会发现，<code>sequence</code>和<code>optional</code>都实现了这两个方法，如下所示：</p><blockquote><p><code>sequence</code>中<code>map</code>和<code>flatMap</code> 的实现</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span></span><br><span class="line">  ) <span class="keyword">rethrows</span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">    <span class="keyword">let</span> initialCapacity = underestimatedCount</span><br><span class="line">    <span class="keyword">var</span> result = <span class="type">ContiguousArray</span>&lt;<span class="type">T</span>&gt;()</span><br><span class="line">    result.reserveCapacity(initialCapacity)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> iterator = <span class="keyword">self</span>.makeIterator()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add elements up to the initial capacity without checking for regrowth.</span></span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;initialCapacity &#123;</span><br><span class="line">      result.append(<span class="keyword">try</span> transform(iterator.next()!))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add remaining elements, if any.</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> element = iterator.next() &#123;</span><br><span class="line">      result.append(<span class="keyword">try</span> transform(element))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Array</span>(result)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;SegmentOfResult : Sequence&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">SegmentOfResult</span></span><br><span class="line">  ) <span class="keyword">rethrows</span> -&gt; [<span class="type">SegmentOfResult</span>.<span class="type">Element</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> result: [<span class="type">SegmentOfResult</span>.<span class="type">Element</span>] = []</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">      result.append(contentsOf: <span class="keyword">try</span> transform(element))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;ElementOfResult&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">ElementOfResult</span>?</span><br><span class="line">  ) <span class="keyword">rethrows</span> -&gt; [<span class="type">ElementOfResult</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> _compactMap(transform)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">_compactMap</span>&lt;ElementOfResult&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">ElementOfResult</span>?</span><br><span class="line">  ) <span class="keyword">rethrows</span> -&gt; [<span class="type">ElementOfResult</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> result: [<span class="type">ElementOfResult</span>] = []</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> newElement = <span class="keyword">try</span> transform(element) &#123;</span><br><span class="line">        result.append(newElement)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>optional</code>中<code>map</code>和<code>flatMap</code>的实现</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> transform: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">U</span></span><br><span class="line">  ) <span class="keyword">rethrows</span> -&gt; <span class="type">U</span>? &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .some(<span class="keyword">let</span> y):</span><br><span class="line">      <span class="keyword">return</span> .some(<span class="keyword">try</span> transform(y))</span><br><span class="line">    <span class="keyword">case</span> .<span class="keyword">none</span>:</span><br><span class="line">      <span class="keyword">return</span> .<span class="keyword">none</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;U&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> transform: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">U</span>?</span><br><span class="line">  ) <span class="keyword">rethrows</span> -&gt; <span class="type">U</span>? &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .some(<span class="keyword">let</span> y):</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">try</span> transform(y)</span><br><span class="line">    <span class="keyword">case</span> .<span class="keyword">none</span>:</span><br><span class="line">      <span class="keyword">return</span> .<span class="keyword">none</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看完源码实现，大家就能够明白上面的用法了，这里就不赘述了，不过我们需要透过现象看本质，看一看Apple到底为什么要这样来设计，他的思想是什么。</p><p>所以，我们来捋一捋，去掉各种不重要的符号，以及<code>sequence</code>中第二个版本的<code>flatMap</code>已经更名为<code>compactMap</code>,表意更清晰，所以也不会混淆了，所以也暂时去掉他，那么<code>sequence</code>和<code>optional</code>中的定义如下：</p><blockquote><p><code>sequence</code>:</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(transform: <span class="params">(Element)</span></span></span> -&gt; <span class="type">T</span>) -&gt; [<span class="type">T</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;SegmentOfResult : Sequence&gt;<span class="params">(transform: <span class="params">(Element)</span></span></span> -&gt; <span class="type">SegmentOfResult</span>) -&gt; [<span class="type">SegmentOfResult</span>.<span class="type">Element</span>]</span><br></pre></td></tr></table></figure><blockquote><p><code>optional</code>:</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(transform: <span class="params">(Wrapped)</span></span></span> -&gt; <span class="type">U</span>) -&gt; <span class="type">U</span>?</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;U&gt;<span class="params">(transform: <span class="params">(Wrapped)</span></span></span> -&gt; <span class="type">U</span>?) -&gt; <span class="type">U</span>?</span><br></pre></td></tr></table></figure><p>我们会发现，<code>sequence</code>中<code>map</code>与<code>flatMap</code>方法的区别主要在于transform方法，一个将element转换为<code>T</code>类型，一个将element转换为<code>sequence</code>类型</p><p>同理，<code>optional</code>中<code>map</code>与<code>flatMap</code>方法的区别主要也在于transform方法，一个将解包后的值转换为<code>U</code>类型，一个将解包后的值转换为<code>U?</code>类型。</p><p>为什么<code>sequence</code>和<code>optional</code>都有这两个方法，有什么关联吗，这个需要我们来了解一下函数式编程一些知识。</p><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>其实很难给出函数式的准确定义，不过有几个概念是函数式编程中经常会遇到的，<code>Functor</code>，<code>Applicative</code>和<code>Monad</code>，之前对这个了解也不是很深，直到后面看到一篇文章，讲的很通俗易懂，想看小伙伴可以点击<a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="noopener">这里</a>来查看原文。</p><h2 id="封装值"><a href="#封装值" class="headerlink" title="封装值"></a>封装值</h2><p>其实这里有一个封装值的概念，我们在编程的时候用到很多基础类型值，譬如3就是一个整型，但是包装值的概念是将整型3放入其中，将其封装起来，对外表现出的类型已经不是整型，可以是其他类型，<code>swift</code>中有一个绝佳的例子<code>enum</code>的Associated Value 如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> success(<span class="type">T</span>)</span><br><span class="line">  <span class="keyword">case</span> fail</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="type">Result</span>.success(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>如上所示，整型3被封装了起来，对外的类型是<code>enum</code>，这就是封装值的概念，下面的诸多例子我们都会用这个<code>Result</code>来演示。</p><p>其实<code>optional</code>就是用<code>enum</code>来实现的如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">None</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Some</span>(<span class="type">T</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以大家该明白了，<code>optional</code>就是一种封装值。</p><h2 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h2><p>我们平时写代码用的最多的函数是处理普通值函数的代码，譬如如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(<span class="number">_</span> number: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = addOne(a)<span class="comment">//b = 2</span></span><br></pre></td></tr></table></figure><p>但是，如果我们把上述的整型a变成封装值，上述的<code>addOne()</code>函数就无法工作了，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="type">Result</span>.success(<span class="number">1</span>)<span class="comment">//a已经变成了一个封装值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(<span class="number">_</span> number: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = addOne(a)<span class="comment">//报错，提示a类型不是Int类型</span></span><br></pre></td></tr></table></figure><p>这时候，我们就需要将封装值从它封装的类型<code>Result</code>里拿出来，再传给<code>addOne()</code>函数，才能正常工作，然后将通过<code>addOne()</code>函数计算好后得到的普通结果值再次封装在<code>Result</code>里，返回这个封装结果值，这个过程就是<code>Functor</code>.</p><p>我们来实现这个<code>Functor</code>，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functor</span><span class="params">(<span class="number">_</span> result: Result&lt;Int&gt;, transform: <span class="params">(Int)</span></span></span>-&gt; <span class="type">Int</span>) -&gt; <span class="type">Result</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .success(value):</span><br><span class="line">        <span class="keyword">return</span> .success(transform(value))</span><br><span class="line">    <span class="keyword">case</span> .fail:</span><br><span class="line">        <span class="keyword">return</span> .fail</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = functor(a, transform: addOne)<span class="comment">//b = .success(2)</span></span><br></pre></td></tr></table></figure><p>如果大家把这个<code>functor</code>函数和上面源码中<code>sequence</code>和<code>optional</code>中<code>map</code>方法的实现比照，就会发现，<code>sequence</code>和<code>optional</code>中的<code>map</code>方法就是<code>Functor</code>思想在<code>swift</code>中的实现，有同学会说<code>sequence</code>中的<code>map</code>好像不是啊，其实如果把数组也看作一种封装值，那就是一样的啦。</p><p><img src="https://i.loli.net/2018/06/28/5b349e05a1db4.jpg" alt="5b349e05a1db4"></p><h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><p>继续上面的例子，如果我们不仅仅a变成封装值，我们的<code>addOne()</code>函数的返回值不再是<code>Int</code>,而是一个封装值，譬如<code>Result&lt;Int&gt;</code>，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(<span class="number">_</span> number: Int)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Result</span>.success(number + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那整个计算过程就需要少许改变一下了，因为我们现在的<code>addOne()</code>函数也返回封装值，如果在用刚刚的<code>functor</code>函数，那返回值就会出现封装值里面嵌套封装值，啊，这绝对是我们不想看到的，我们来修改一下<code>functor</code>函数，取个新函数名<code>monad</code>如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">monad</span><span class="params">(<span class="number">_</span> result: Result&lt;Int&gt;, transform: <span class="params">(Int)</span></span></span>-&gt; <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .success(value):</span><br><span class="line">        <span class="keyword">return</span> transform(value)</span><br><span class="line">    <span class="keyword">case</span> .fail:</span><br><span class="line">        <span class="keyword">return</span> .fail</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = monad(a, transform: addOne)<span class="comment">//c = .success(2)</span></span><br></pre></td></tr></table></figure><p>如果大家把这个<code>monad</code>函数和上面源码中<code>sequence</code>和<code>optional</code>中<code>flatMap</code>方法的实现比照，就会发现，<code>sequence</code>和<code>optional</code>中的<code>flatMap</code>方法就是<code>Monad</code>思想在<code>swift</code>中的实现。</p><p>但是<code>Monad</code>绝对不仅仅是降维这么简单，它真正厉害的地方是可以将多个函数串联起来，将原来一个完整的流程拆分为多个函数的串联，每个函数完成一个单独的功能，串联起来实现一个复杂的功能，我觉得<code>Monad</code>不单单是个函数，更多的是一种思想，一种解决问题的思路。</p><p>我们看一个用这个思想解决的一个问题。</p><h2 id="用函数式思想解决网络请求问题"><a href="#用函数式思想解决网络请求问题" class="headerlink" title="用函数式思想解决网络请求问题"></a>用函数式思想解决网络请求问题</h2><p>大家经常遇到这样的需求，判断有没有网络-&gt;获取接口数据成功与否-&gt;解析数据成功与否-&gt;保存数据成功与否，为了演示，我写了几个函数如下方便大家理解：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkNet</span><span class="params">()</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Bool</span>&gt;<span class="comment">//检查网络</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchData</span><span class="params">(canFetch: Bool)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Data</span>&gt;<span class="comment">//获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseData</span><span class="params">(data: Data)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Dictionary</span>&gt;<span class="comment">//解析数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saveData</span><span class="params">(diationary: Dictionary)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">String</span>&gt;<span class="comment">//保存数据</span></span><br></pre></td></tr></table></figure><p>我们以前常用的做法是if判断，肯定没问题，但是如果我们尝试用上面提到的函数式思想去考虑的话也许就有更好的方法。</p><p>下面是我自己写的常用的一个用以处理结果的类，并将<code>map</code>和<code>flatMap</code>的操作自定义成一个操作符，方便串连调用，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="comment">///This enumuration describes the result of all situation.</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> success(<span class="type">T</span>)</span><br><span class="line">    <span class="keyword">case</span> failure(<span class="type">Error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="comment">///Functor</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .success(<span class="keyword">let</span> v):</span><br><span class="line">            <span class="keyword">return</span> .success(transform(v))</span><br><span class="line">        <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">            <span class="keyword">return</span> .failure(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///Applicative</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">apply</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transform: Result&lt;<span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> transform &#123;</span><br><span class="line">        <span class="keyword">case</span> .success(<span class="keyword">let</span> function):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.<span class="built_in">map</span>(function)</span><br><span class="line">        <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">            <span class="keyword">return</span> .failure(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///Monad</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(T)</span></span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .success(<span class="keyword">let</span> v):</span><br><span class="line">            <span class="keyword">return</span> transform(v)</span><br><span class="line">        <span class="keyword">case</span> .failure(<span class="keyword">let</span> e):</span><br><span class="line">            <span class="keyword">return</span> .failure(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">precedencegroup <span class="type">ChainingPrecedence</span> &#123;</span><br><span class="line">    <span class="keyword">associativity</span>: <span class="keyword">left</span></span><br><span class="line">    higherThan: <span class="type">TernaryPrecedence</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///Functor</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &lt;^&gt;: <span class="type">ChainingPrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> &lt;^&gt;&lt;T, U&gt;<span class="params">(lhs: <span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>, rhs: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs.<span class="built_in">map</span>(lhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///Applicative</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &lt;*&gt;: <span class="type">ChainingPrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> &lt;*&gt;&lt;T, U&gt;<span class="params">(lhs: Result&lt;<span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>&gt;, rhs: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs.apply(lhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///Monad</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &gt;&gt;-: <span class="type">ChainingPrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> &gt;&gt;-&lt;T, U&gt;<span class="params">(lhs: Result&lt;T&gt;, rhs: <span class="params">(T)</span></span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.flatMap(rhs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那这个问题可以简单的这样处理 ，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = checkNet()&gt;&gt;-fetchData&gt;&gt;-parseData&gt;&gt;-saveData</span><br></pre></td></tr></table></figure><p>哪一个步骤出错了，错误信息也都能捕捉到，所以这样子是不是就是简单了好多，代码优雅了好多。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>swift</code> 是一门多编程范式语言，对于函数式编程的思想集成的很好，标准库已经实现了很多高阶函数，<code>FP</code>思想很多时候能在一些问题的处理上带给我们不同的思路和解决方法，希望以上的信息能够帮到你，谢谢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;flatMap&lt;/code&gt;是swift中两个高阶函数，用处很大，其实不仅仅是这两个函数，其他的譬如&lt;code&gt;reduce&lt;/code&gt;，&lt;code&gt;filter&lt;/code&gt;等等，都为我们提供了很多功能，是之前在oc里无法提
      
    
    </summary>
    
      <category term="swift" scheme="http://yoursite.com/categories/swift/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
      <category term="函数式编程" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
