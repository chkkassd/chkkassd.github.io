<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Uncle Peter</title>
  
  <subtitle>无他,但手熟尔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-02T12:19:39.653Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Uncle Peter</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>swift中copy on write的研究</title>
    <link href="http://yoursite.com/2018/03/05/swift%E4%B8%ADcopy%20on%20write%E7%9A%84%E7%A0%94%E7%A9%B6/"/>
    <id>http://yoursite.com/2018/03/05/swift中copy on write的研究/</id>
    <published>2018-03-05T02:19:49.000Z</published>
    <updated>2018-07-02T12:19:39.653Z</updated>
    
    <content type="html"><![CDATA[<p>本文部分相关知识参考了《Advanced Swift》以及<a href="https://www.boxueio.com" target="_blank" rel="noopener">泊学网</a></p><h1 id="什么是写时复制-copy-on-write"><a href="#什么是写时复制-copy-on-write" class="headerlink" title="什么是写时复制(copy-on-write)"></a>什么是写时复制(copy-on-write)</h1><p>在<code>swift</code>标准库中，像<code>Array</code>,<code>Dictionary</code>,<code>Set</code>这些结构体都实现了写时复制技术，那到底什么是写时复制呢？我们看一个例子就明白了，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">var</span> b = a</span><br></pre></td></tr></table></figure><p>如上面的代码所示，我们创建了一个数组<code>a</code>，同时我们将<code>a</code>赋给<code>b</code>，这是很常见的操作，其实这个时候，a和b是两个独立的值，但是在内部，a和b都是指向内存中同一个位置的引用，其实这两个数组共享了他们的存储部分，也就是说在堆内存中只有一份这样的数据，但是a和b都引用了这份数据。如果我们再增加一个操作，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.append(<span class="number">4</span>)<span class="comment">//[1,2,3,4]</span></span><br><span class="line">b<span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure><p>在这种时候，<code>swift</code>就会对内存进行复制，然后在复制的值上进行处理，从而不影响原来的那份值，也就是说只在必要的时候去复制。</p><p>总结一下就是：每当值类型内容发生变化时，它会首先检查对存储缓冲区的引用是否唯一，如果只有自己一个引用，那就在这份存储数据上原地修改即可，不会有复制发生。如果发现对存储缓冲区有不止一个引用，例如上面的例子，那么就会先进行复制，然后对复制的值进行操作，以免影响其他引用。总之只在必要时复制，否则不会复制。</p><p>在标准库中的集合类型，譬如<code>Array</code>,<code>Dictionary</code>,<code>Set</code>这些结构体都实现了写时复制技术，我们只管使用即可，它保持了值语义，同时也优化了性能，避免了昂贵的不必要的复制操作，但是这个福利并不是所有值类型都有，当我们自己创建一些值类型的时候，特别是我们自定义的值类型里包含引用类型对象时，为了保持值语义，我们就得自己来实现<code>copy-on-write</code>了。</p><h1 id="我们自己动手来实现COW"><a href="#我们自己动手来实现COW" class="headerlink" title="我们自己动手来实现COW"></a>我们自己动手来实现COW</h1><h2 id="一个比较粗糙的copy-on-write实现"><a href="#一个比较粗糙的copy-on-write实现" class="headerlink" title="一个比较粗糙的copy-on-write实现"></a>一个比较粗糙的copy-on-write实现</h2><p>譬如我们来实现一个我们自定义的<code>Array</code>，里面用来存储数据的是一个oc对象，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> elements: <span class="type">NSMutableArray</span></span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> elements: <span class="type">NSMutableArray</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.elements = elements.mutableCopy() <span class="keyword">as</span>! <span class="type">NSMutableArray</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了实现值语义，我们将传入的elements复制一份，赋给内部的elements变量。同时，为了在操作<code>CustomArray</code>对象时隐藏<code>elements</code>属性，我们为它添加一个方法，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CustomArray</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> element: Any)</span></span> &#123;</span><br><span class="line">        elements.insert(element, at: elements.<span class="built_in">count</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我们平常会写的代码，但是这样会有问题，看如下操作：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aArr = <span class="type">CustomArray</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> bArr = aArr</span><br><span class="line">aArr.append(<span class="number">4</span>)</span><br><span class="line">aArr.elements === bArr.elements<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p><code>aArr</code>和<code>bArr</code>是两个独立的结构体，按照我们之前对copy-on-write的理解，当<code>aArr</code>内容发生变更时，会被复制一份，那么<code>aArr</code>和<code>bArr</code>将不再享有同一份内存数据，而是两份独立的数据，内存不再共享，但是上面的<code>aArr</code>和<code>bArr</code>中<code>elements</code>却仍旧是同一个引用对象，这个可以理解，因为我们没有对它做任何特殊处理，但是这样子却是不符合值语义的，所以为了保持值语义，我们需要来实现copy-on-write，我们来修改一下代码，我们创建一个计算属性<code>elementsCOW</code>，每当自定义数组需要改变内容时，我们都使用这个计算属性，来对内部的elements进行复制，然后使用这份拷贝来进行操作。相应的<code>append</code>方法都会使用这个计算属性，代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> elementsCOW: <span class="type">NSMutableArray</span> &#123;</span><br><span class="line">        <span class="keyword">mutating</span> <span class="keyword">get</span> &#123;</span><br><span class="line">            elements = elements.mutableCopy() <span class="keyword">as</span>! <span class="type">NSMutableArray</span></span><br><span class="line">            <span class="keyword">return</span> elements</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CustomArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> element: Any)</span></span> &#123;</span><br><span class="line">        elementsCOW.insert(element, at: elementsCOW.<span class="built_in">count</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样子的话，每次<code>append</code>新的元素，都会对内部<code>elements</code>进行拷贝后，使用拷贝的值进行添加操作，完全符合了值语义，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> aArr = <span class="type">CustomArray</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="keyword">let</span> bArr = aArr</span><br><span class="line">aArr.append(<span class="number">4</span>)</span><br><span class="line">aArr.elements === bArr.elements<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>如果这样就完成了，那就太简单了，<img src="https://i.loli.net/2018/07/02/5b39fae014738.jpg" alt="5b39fae014738"></p><p>如果这样，我们确实为自定义的数组实现了值语义，每次使用修改时，都会复制一份，但是你会发现，如果这样，像上述的例子那样，如果没有<code>bArr</code>，只有一个<code>aArr</code>，我们每次都对<code>aArr</code>进行修改都会被复制一份，譬如这样：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> &#123;</span><br><span class="line">    aArr.append(i)<span class="comment">//aArr会被复制10次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的<code>aArr</code>会被复制10次，这样太不合理，内存明明只有一个引用，不会影响到其他对象使用，太浪费了。所以我们需要对上述代码在做一次更改，只在必要的时候复制。我们的思路是这样的，当值被更改时，判断对象是否只有一个引用，如果是，那就不复制，如果不是，那就需要复制一份。</p><h2 id="一个更高效的copy-on-write实现"><a href="#一个更高效的copy-on-write实现" class="headerlink" title="一个更高效的copy-on-write实现"></a>一个更高效的copy-on-write实现</h2><p>为此我们需要用到一个方法swift标准库中的<code>isKnownUniquelyReferenced</code>，对于Swift原生类对象，只有单一引用时返回<code>true</code>，否则返回<code>false</code>；对于Objective-C中的类对象，总是返回<code>false</code>，所以我们还不能直接用，我们需要把oc对象封装在swift对象之内，所以我们这样来做，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Pack</span>&lt;<span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> unpack: <span class="type">U</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> unpack: <span class="type">U</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.unpack = unpack</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们自定义一个类型<code>Pack</code>用来打包oc对象，使用<code>final</code>，不想让它被继承。然后我们可以修改一下上面的代码，内部元素<code>elements</code>可以打包，并且判断打包好后的swift类型是否只有唯一引用，不是的话就复制，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomArray</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> elementsCOW: <span class="type">NSMutableArray</span> &#123;</span><br><span class="line">        <span class="keyword">mutating</span> <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> !isKnownUniquelyReferenced(&amp;elements) &#123;</span><br><span class="line">                elements = <span class="type">Pack</span>(elements.unpack.mutableCopy() <span class="keyword">as</span>! <span class="type">NSMutableArray</span>)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"occur copy"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> elements.unpack</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> elements: <span class="type">Pack</span>&lt;<span class="type">NSMutableArray</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="number">_</span> elements: <span class="type">NSMutableArray</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.elements = <span class="type">Pack</span>(elements.mutableCopy() <span class="keyword">as</span>! <span class="type">NSMutableArray</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，再次执行原先的代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>...<span class="number">10</span> &#123;</span><br><span class="line">    aArr.append(i)<span class="comment">//aArr将不再被复制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，一个更加高效的写时复制完成了，它保证了我们自定义数组的值语义，并且只在必要的时候才去复制。</p><p><img src="https://i.loli.net/2018/07/02/5b3a1499291b6.jpg" alt="5b3a1499291b6"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在swift中，值类型是非常重要的类型，你会发现原来OC中是引用类型的数组，字典等在swift中都是值类型，因为更安全，高效。我们在自定义一些值类型时，为了维护值语义，通常都需要在每次变更时，都进行昂贵的复制操作，但是写时复制技术避免了在非必要的情况下的复制操作。希望以上这些可以帮到你。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文部分相关知识参考了《Advanced Swift》以及&lt;a href=&quot;https://www.boxueio.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;泊学网&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;什么是写时复制-copy-on-write&quot;&gt;
      
    
    </summary>
    
      <category term="swift" scheme="http://yoursite.com/categories/swift/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>swift中map与flatMap的用法与研究</title>
    <link href="http://yoursite.com/2018/02/26/swift%E4%B8%ADmap%E4%B8%8EflatMap%E7%9A%84%E7%94%A8%E6%B3%95%E4%B8%8E%E7%A0%94%E7%A9%B6/"/>
    <id>http://yoursite.com/2018/02/26/swift中map与flatMap的用法与研究/</id>
    <published>2018-02-26T02:19:49.000Z</published>
    <updated>2018-07-02T06:12:03.333Z</updated>
    
    <content type="html"><![CDATA[<p><code>map</code>和<code>flatMap</code>是swift中两个高阶函数，用处很大，其实不仅仅是这两个函数，其他的譬如<code>reduce</code>，<code>filter</code>等等，都为我们提供了很多功能，是之前在oc里无法提供，或者需要自己去实现的。当然这些函数在其他语言里是一直存在的，譬如<code>Haskell</code>。所以<code>swift</code>是一门多编程范式的语言，这里只是记录一下<code>map</code>和<code>flatMap</code>的用法，以及通过这个，我们来看一下函数式思想在<code>swfit</code>中的运用。</p><h1 id="map和flatMap用法"><a href="#map和flatMap用法" class="headerlink" title="map和flatMap用法"></a>map和flatMap用法</h1><p>我们直接看例子：</p><blockquote><p>例1  数组中使用</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.<span class="built_in">map</span> &#123;$<span class="number">0</span> + <span class="number">1</span>&#125;<span class="comment">//[2,3,4],将数组中每一个整数加一然后返回,返回值类型是Array</span></span><br><span class="line"><span class="keyword">let</span> arr3 = arr.flatMap &#123;[$<span class="number">0</span> - <span class="number">1</span>, $<span class="number">0</span> + <span class="number">1</span>]&#125;<span class="comment">//[0, 2, 1, 3, 2, 4]，将数组中每一个整型元素映射成了一个数组，如果用map将会得到一个二维数组，所以用flatmap降维成一维数组</span></span><br></pre></td></tr></table></figure><blockquote><p>例2  数组的<code>flatMap</code>(在swift4.1中，已经改名为compactMap,下面的源码也贴了出来)还有另外一种用法</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> brr = [<span class="string">"1"</span>, <span class="string">"2"</span>,<span class="string">"三"</span>, <span class="string">"4"</span>]</span><br><span class="line"><span class="comment">//let brr2 = brr.compactMap &#123;Int($0)&#125;</span></span><br><span class="line"><span class="keyword">let</span> brr2 = brr.flatMap &#123;<span class="type">Int</span>($<span class="number">0</span>)&#125;<span class="comment">//[1, 2, 4],Int()函数将String转成Int类型，有可能成功，也有可能失败，所以返回值类型是Optional&lt;Int&gt;,很明显这边数组brr里的"三"是无法成功转换成整型3的，所以返回nil，结果是[1,2,nil,4],此时的flatMap可以过滤掉了nil</span></span><br></pre></td></tr></table></figure><p>因为这个<code>flatMap</code>除了 降维之外其实还有 filter 的作用，在使用时容易产生歧义，所以社区认为最好把这个flatMap重新拆分出来，使用一个新的方法命名，所以就有了<code>compactMap</code>。</p><blockquote><p>例3  <code>optional</code>中使用</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str: <span class="type">String</span>? = <span class="string">"12"</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = str.<span class="built_in">map</span> &#123;$<span class="number">0</span>.<span class="built_in">count</span>&#125;<span class="comment">//count = 2,如果这个str有值，就计算这个string的字符个数，如果没有值，就返回nil，注意count的类型为Optional&lt;Int&gt;</span></span><br><span class="line"><span class="keyword">let</span> value = str.flatMap &#123;<span class="type">Int</span>($<span class="number">0</span>)&#125;<span class="comment">//value = 12,和上面数组中使用一样，Int()函数将String转成Int类型，有可能成功，也有可能失败，所以返回值类型是Optional&lt;Int&gt;，此时如果使用map，那么value返回的类型会变成Optional&lt;Optional&lt;Int&gt;&gt;，嵌套的optional，所以使用flatMap，其实也是降维的概念，使其返回类型变为Optional&lt;Int&gt;。</span></span><br></pre></td></tr></table></figure><h1 id="map和flatMap在标准库中的实现"><a href="#map和flatMap在标准库中的实现" class="headerlink" title="map和flatMap在标准库中的实现"></a>map和flatMap在标准库中的实现</h1><p>没有什么比看源码更能直接了当的了解一个类或者方法了，大家也可以直接去<a href="https://github.com/apple/swift/tree/master/stdlib/public/core" target="_blank" rel="noopener">swift源码</a>查看。我们会发现，<code>sequence</code>和<code>optional</code>都实现了这两个方法，如下所示：</p><blockquote><p><code>sequence</code>中<code>map</code>和<code>flatMap</code> 的实现</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span></span><br><span class="line">  ) <span class="keyword">rethrows</span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">    <span class="keyword">let</span> initialCapacity = underestimatedCount</span><br><span class="line">    <span class="keyword">var</span> result = <span class="type">ContiguousArray</span>&lt;<span class="type">T</span>&gt;()</span><br><span class="line">    result.reserveCapacity(initialCapacity)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> iterator = <span class="keyword">self</span>.makeIterator()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add elements up to the initial capacity without checking for regrowth.</span></span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;initialCapacity &#123;</span><br><span class="line">      result.append(<span class="keyword">try</span> transform(iterator.next()!))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add remaining elements, if any.</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> element = iterator.next() &#123;</span><br><span class="line">      result.append(<span class="keyword">try</span> transform(element))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Array</span>(result)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;SegmentOfResult : Sequence&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">SegmentOfResult</span></span><br><span class="line">  ) <span class="keyword">rethrows</span> -&gt; [<span class="type">SegmentOfResult</span>.<span class="type">Element</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> result: [<span class="type">SegmentOfResult</span>.<span class="type">Element</span>] = []</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">      result.append(contentsOf: <span class="keyword">try</span> transform(element))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;ElementOfResult&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">ElementOfResult</span>?</span><br><span class="line">  ) <span class="keyword">rethrows</span> -&gt; [<span class="type">ElementOfResult</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> _compactMap(transform)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">_compactMap</span>&lt;ElementOfResult&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">ElementOfResult</span>?</span><br><span class="line">  ) <span class="keyword">rethrows</span> -&gt; [<span class="type">ElementOfResult</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> result: [<span class="type">ElementOfResult</span>] = []</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> newElement = <span class="keyword">try</span> transform(element) &#123;</span><br><span class="line">        result.append(newElement)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>optional</code>中<code>map</code>和<code>flatMap</code>的实现</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> transform: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">U</span></span><br><span class="line">  ) <span class="keyword">rethrows</span> -&gt; <span class="type">U</span>? &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .some(<span class="keyword">let</span> y):</span><br><span class="line">      <span class="keyword">return</span> .some(<span class="keyword">try</span> transform(y))</span><br><span class="line">    <span class="keyword">case</span> .<span class="keyword">none</span>:</span><br><span class="line">      <span class="keyword">return</span> .<span class="keyword">none</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;U&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> transform: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">U</span>?</span><br><span class="line">  ) <span class="keyword">rethrows</span> -&gt; <span class="type">U</span>? &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .some(<span class="keyword">let</span> y):</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">try</span> transform(y)</span><br><span class="line">    <span class="keyword">case</span> .<span class="keyword">none</span>:</span><br><span class="line">      <span class="keyword">return</span> .<span class="keyword">none</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看完源码实现，大家就能够明白上面的用法了，这里就不赘述了，不过我们需要透过现象看本质，看一看Apple到底为什么要这样来设计，他的思想是什么。</p><p>所以，我们来捋一捋，去掉各种不重要的符号，以及<code>sequence</code>中第二个版本的<code>flatMap</code>已经更名为<code>compactMap</code>,表意更清晰，所以也不会混淆了，所以也暂时去掉他，那么<code>sequence</code>和<code>optional</code>中的定义如下：</p><blockquote><p><code>sequence</code>:</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(transform: <span class="params">(Element)</span></span></span> -&gt; <span class="type">T</span>) -&gt; [<span class="type">T</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;SegmentOfResult : Sequence&gt;<span class="params">(transform: <span class="params">(Element)</span></span></span> -&gt; <span class="type">SegmentOfResult</span>) -&gt; [<span class="type">SegmentOfResult</span>.<span class="type">Element</span>]</span><br></pre></td></tr></table></figure><blockquote><p><code>optional</code>:</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(transform: <span class="params">(Wrapped)</span></span></span> -&gt; <span class="type">U</span>) -&gt; <span class="type">U</span>?</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;U&gt;<span class="params">(transform: <span class="params">(Wrapped)</span></span></span> -&gt; <span class="type">U</span>?) -&gt; <span class="type">U</span>?</span><br></pre></td></tr></table></figure><p>我们会发现，<code>sequence</code>中<code>map</code>与<code>flatMap</code>方法的区别主要在于transform方法，一个将element转换为<code>T</code>类型，一个将element转换为<code>sequence</code>类型</p><p>同理，<code>optional</code>中<code>map</code>与<code>flatMap</code>方法的区别主要也在于transform方法，一个将解包后的值转换为<code>U</code>类型，一个将解包后的值转换为<code>U?</code>类型。</p><p>为什么<code>sequence</code>和<code>optional</code>都有这两个方法，有什么关联吗，这个需要我们来了解一下函数式编程一些知识。</p><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>其实很难给出函数式的准确定义，不过有几个概念是函数式编程中经常会遇到的，<code>Functor</code>，<code>Applicative</code>和<code>Monad</code>，之前对这个了解也不是很深，直到后面看到一篇文章，讲的很通俗易懂，想看小伙伴可以点击<a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="noopener">这里</a>来查看原文。</p><h2 id="封装值"><a href="#封装值" class="headerlink" title="封装值"></a>封装值</h2><p>其实这里有一个封装值的概念，我们在编程的时候用到很多基础类型值，譬如3就是一个整型，但是包装值的概念是将整型3放入其中，将其封装起来，对外表现出的类型已经不是整型，可以是其他类型，<code>swift</code>中有一个绝佳的例子<code>enum</code>的Associated Value 如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> success(<span class="type">T</span>)</span><br><span class="line">  <span class="keyword">case</span> fail</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="type">Result</span>.success(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>如上所示，整型3被封装了起来，对外的类型是<code>enum</code>，这就是封装值的概念，下面的诸多例子我们都会用这个<code>Result</code>来演示。</p><p>其实<code>optional</code>就是用<code>enum</code>来实现的如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">None</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Some</span>(<span class="type">T</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以大家该明白了，<code>optional</code>就是一种封装值。</p><h2 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h2><p>我们平时写代码用的最多的函数是处理普通值函数的代码，譬如如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(<span class="number">_</span> number: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = addOne(a)<span class="comment">//b = 2</span></span><br></pre></td></tr></table></figure><p>但是，如果我们把上述的整型a变成封装值，上述的<code>addOne()</code>函数就无法工作了，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="type">Result</span>.success(<span class="number">1</span>)<span class="comment">//a已经变成了一个封装值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(<span class="number">_</span> number: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = addOne(a)<span class="comment">//报错，提示a类型不是Int类型</span></span><br></pre></td></tr></table></figure><p>这时候，我们就需要将封装值从它封装的类型<code>Result</code>里拿出来，再传给<code>addOne()</code>函数，才能正常工作，然后将通过<code>addOne()</code>函数计算好后得到的普通结果值再次封装在<code>Result</code>里，返回这个封装结果值，这个过程就是<code>Functor</code>.</p><p>我们来实现这个<code>Functor</code>，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functor</span><span class="params">(<span class="number">_</span> result: Result&lt;Int&gt;, transform: <span class="params">(Int)</span></span></span>-&gt; <span class="type">Int</span>) -&gt; <span class="type">Result</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .success(value):</span><br><span class="line">        <span class="keyword">return</span> .success(transform(value))</span><br><span class="line">    <span class="keyword">case</span> .fail:</span><br><span class="line">        <span class="keyword">return</span> .fail</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = functor(a, transform: addOne)<span class="comment">//b = .success(2)</span></span><br></pre></td></tr></table></figure><p>如果大家把这个<code>functor</code>函数和上面源码中<code>sequence</code>和<code>optional</code>中<code>map</code>方法的实现比照，就会发现，<code>sequence</code>和<code>optional</code>中的<code>map</code>方法就是<code>Functor</code>思想在<code>swift</code>中的实现，有同学会说<code>sequence</code>中的<code>map</code>好像不是啊，其实如果把数组也看作一种封装值，那就是一样的啦。</p><p><img src="https://i.loli.net/2018/06/28/5b349e05a1db4.jpg" alt="5b349e05a1db4"></p><h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><p>继续上面的例子，如果我们不仅仅a变成封装值，我们的<code>addOne()</code>函数的返回值不再是<code>Int</code>,而是一个封装值，譬如<code>Result&lt;Int&gt;</code>，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(<span class="number">_</span> number: Int)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Result</span>.success(number + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那整个计算过程就需要少许改变一下了，因为我们现在的<code>addOne()</code>函数也返回封装值，如果在用刚刚的<code>functor</code>函数，那返回值就会出现封装值里面嵌套封装值，啊，这绝对是我们不想看到的，我们来修改一下<code>functor</code>函数，取个新函数名<code>monad</code>如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">monad</span><span class="params">(<span class="number">_</span> result: Result&lt;Int&gt;, transform: <span class="params">(Int)</span></span></span>-&gt; <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .success(value):</span><br><span class="line">        <span class="keyword">return</span> transform(value)</span><br><span class="line">    <span class="keyword">case</span> .fail:</span><br><span class="line">        <span class="keyword">return</span> .fail</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = monad(a, transform: addOne)<span class="comment">//c = .success(2)</span></span><br></pre></td></tr></table></figure><p>如果大家把这个<code>monad</code>函数和上面源码中<code>sequence</code>和<code>optional</code>中<code>flatMap</code>方法的实现比照，就会发现，<code>sequence</code>和<code>optional</code>中的<code>flatMap</code>方法就是<code>Monad</code>思想在<code>swift</code>中的实现。</p><p>但是<code>Monad</code>绝对不仅仅是降维这么简单，它真正厉害的地方是可以将多个函数串联起来，将原来一个完整的流程拆分为多个函数的串联，每个函数完成一个单独的功能，串联起来实现一个复杂的功能，我觉得<code>Monad</code>不单单是个函数，更多的是一种思想，一种解决问题的思路。</p><p>我们看一个用这个思想解决的一个问题。</p><h2 id="用函数式思想解决网络请求问题"><a href="#用函数式思想解决网络请求问题" class="headerlink" title="用函数式思想解决网络请求问题"></a>用函数式思想解决网络请求问题</h2><p>大家经常遇到这样的需求，判断有没有网络-&gt;获取接口数据成功与否-&gt;解析数据成功与否-&gt;保存数据成功与否，为了演示，我写了几个函数如下方便大家理解：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkNet</span><span class="params">()</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Bool</span>&gt;<span class="comment">//检查网络</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchData</span><span class="params">(canFetch: Bool)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Data</span>&gt;<span class="comment">//获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseData</span><span class="params">(data: Data)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Dictionary</span>&gt;<span class="comment">//解析数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saveData</span><span class="params">(diationary: Dictionary)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">String</span>&gt;<span class="comment">//保存数据</span></span><br></pre></td></tr></table></figure><p>我们以前常用的做法是if判断，肯定没问题，但是如果我们尝试用上面提到的函数式思想去考虑的话也许就有更好的方法。</p><p>下面是我自己写的常用的一个用以处理结果的类，并将<code>map</code>和<code>flatMap</code>的操作自定义成一个操作符，方便串连调用，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="comment">///This enumuration describes the result of all situation.</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> success(<span class="type">T</span>)</span><br><span class="line">    <span class="keyword">case</span> failure(<span class="type">Error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="comment">///Functor</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .success(<span class="keyword">let</span> v):</span><br><span class="line">            <span class="keyword">return</span> .success(transform(v))</span><br><span class="line">        <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">            <span class="keyword">return</span> .failure(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///Applicative</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">apply</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transform: Result&lt;<span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> transform &#123;</span><br><span class="line">        <span class="keyword">case</span> .success(<span class="keyword">let</span> function):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.<span class="built_in">map</span>(function)</span><br><span class="line">        <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">            <span class="keyword">return</span> .failure(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///Monad</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(T)</span></span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .success(<span class="keyword">let</span> v):</span><br><span class="line">            <span class="keyword">return</span> transform(v)</span><br><span class="line">        <span class="keyword">case</span> .failure(<span class="keyword">let</span> e):</span><br><span class="line">            <span class="keyword">return</span> .failure(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">precedencegroup <span class="type">ChainingPrecedence</span> &#123;</span><br><span class="line">    <span class="keyword">associativity</span>: <span class="keyword">left</span></span><br><span class="line">    higherThan: <span class="type">TernaryPrecedence</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///Functor</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &lt;^&gt;: <span class="type">ChainingPrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> &lt;^&gt;&lt;T, U&gt;<span class="params">(lhs: <span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>, rhs: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs.<span class="built_in">map</span>(lhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///Applicative</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &lt;*&gt;: <span class="type">ChainingPrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> &lt;*&gt;&lt;T, U&gt;<span class="params">(lhs: Result&lt;<span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>&gt;, rhs: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs.apply(lhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///Monad</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &gt;&gt;-: <span class="type">ChainingPrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> &gt;&gt;-&lt;T, U&gt;<span class="params">(lhs: Result&lt;T&gt;, rhs: <span class="params">(T)</span></span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.flatMap(rhs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那这个问题可以简单的这样处理 ，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = checkNet()&gt;&gt;-fetchData&gt;&gt;-parseData&gt;&gt;-saveData</span><br></pre></td></tr></table></figure><p>哪一个步骤出错了，错误信息也都能捕捉到，所以这样子是不是就是简单了好多，代码优雅了好多。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>swift</code> 是一门多编程范式语言，对于函数式编程的思想集成的很好，标准库已经实现了很多高阶函数，<code>FP</code>思想很多时候能在一些问题的处理上带给我们不同的思路和解决方法，希望以上的信息能够帮到你，谢谢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;flatMap&lt;/code&gt;是swift中两个高阶函数，用处很大，其实不仅仅是这两个函数，其他的譬如&lt;code&gt;reduce&lt;/code&gt;，&lt;code&gt;filter&lt;/code&gt;等等，都为我们提供了很多功能，是之前在oc里无法提
      
    
    </summary>
    
      <category term="swift" scheme="http://yoursite.com/categories/swift/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
      <category term="函数式编程" scheme="http://yoursite.com/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>swift中的Initialization</title>
    <link href="http://yoursite.com/2017/07/04/swift%E4%B8%AD%E7%9A%84Initialization/"/>
    <id>http://yoursite.com/2017/07/04/swift中的Initialization/</id>
    <published>2017-07-04T08:34:49.000Z</published>
    <updated>2018-07-05T07:44:20.928Z</updated>
    
    <content type="html"><![CDATA[<p>本文相关知识参考了Apple官方的<a href="https://docs.swift.org/swift-book/LanguageGuide/Initialization.html" target="_blank" rel="noopener">Swift文档</a></p><p>Initialization也就是我们说的构造方法，class，struct，enumeration都会通过这个方法来构造一个自己的实例对象，并在这个过程中做一些必要的初始化。但是和Objective-C不一样的是，你会发现swift中的构造方法没有返回值。他们的主要作用就是保证一个类型的实例在被第一次使用前，能够被正确的构造出来，并初始化。class类型的实例还会有析构函数（Deinitialization）。我们还是通过<code>struct</code>和<code>class</code>具体来看一下他们的用法和原理吧。</p><h1 id="struct的Initialization"><a href="#struct的Initialization" class="headerlink" title="struct的Initialization"></a>struct的Initialization</h1><p>无论是struct还是class，他们的实例在被构造的过程中必须要保证所有的<code>stored properties</code>全都被初始化成功，也就是说所有的存储属性必须都有值，否者无法被正确构造。所以基于此，常规构造方法如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    name = <span class="string">"Peter"</span></span><br><span class="line">    age = <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> peopleOne = <span class="type">People</span>()<span class="comment">//name = peter, age = 18</span></span><br></pre></td></tr></table></figure><p>但是同样的，我们也可以为struct的存储属性设置默认值，这样它就能获得一个默认构造方法，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Peter"</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> peopleOne = <span class="type">People</span>()<span class="comment">//name = peter, age = 18</span></span><br></pre></td></tr></table></figure><p>但是很多时候为了更好的适用性，我们通常会自定义我们想要的构造方法，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">init</span>(personName name: <span class="type">String</span>, <span class="number">_</span> age: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> peopleOne = <span class="type">People</span>(personName: <span class="string">"Peter"</span>, <span class="number">18</span>)<span class="comment">//name = peter, age = 18</span></span><br></pre></td></tr></table></figure><p>上面构造方法中的<code>personName</code>叫做<code>Argument Label</code>是在构造方法被外部调用时使用的，而它后面的<code>name</code>叫做<code>Parameter Name</code>是在构造方法内部使用的，如果希望外部调用的时候简洁一些，不要<code>Argument Label</code>那就可以直接用<code>__</code>下划线替代。</p><h2 id="Memberwise-Initializers"><a href="#Memberwise-Initializers" class="headerlink" title="Memberwise Initializers"></a>Memberwise Initializers</h2><p>struct还有一个很特别的默认提供的构造方法，<code>Memberwise Initializers</code>，我们可以把它叫做逐一成员构造法，按照字面意思即可理解，就是将他的所有成员逐个全部赋值，只要struct没有自定义的构造方法，那么就会默认获得这个构造方法。用法如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> peopleOne = <span class="type">People</span>(ame: <span class="string">"Peter"</span>, age: <span class="number">18</span>)<span class="comment">//name = peter, age = 18</span></span><br></pre></td></tr></table></figure><h2 id="值类型的构造器代理"><a href="#值类型的构造器代理" class="headerlink" title="值类型的构造器代理"></a>值类型的构造器代理</h2><p>什么是构造器代理(Initializer Delegation)，值类型的构造器代理其实就是类型里面有不止一个构造方法，其中一个构造方法的实现里调用了本类型里的另一个构造方法，来避免一些重复的代码。class类型因为有继承的关系，构造器代理会复杂很多，我们下面会讲。直接看代码就明白了，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">init</span>(personName name: <span class="type">String</span>, <span class="number">_</span> age: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span>(info: (<span class="type">String</span>, <span class="type">Int</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> infoName = info.<span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> infoAge = info.<span class="number">1</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(personName: infoName, infoAge)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> peopleOne = <span class="type">People</span>(info: (<span class="string">"Peter"</span>, <span class="number">18</span>))<span class="comment">//name = peter, age = 18</span></span><br></pre></td></tr></table></figure><p>上面的代码，我们定义了另外一个构造器，入参是一个<code>(String, Int)</code>类型的<code>Tuple</code>，但是我们在它的实现里，通过代理给原有的构造方法来实现了完整构造，并节省了重复代码。</p><p><img src="https://i.loli.net/2018/07/05/5b3d85e43385a.jpg" alt="开心"></p><h1 id="class的Initialization"><a href="#class的Initialization" class="headerlink" title="class的Initialization"></a>class的Initialization</h1><p>类类型中的构造方法比起值类型来说，要复杂一些，因为它可以继承等，我们还是通过例子从最简单的开始说起，同样的，如果类里面给所有的存储属性提供了默认值，那么它可以获得一个默认的构造方法<code>init()</code>，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Peter"</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> personOne = <span class="type">Person</span>()<span class="comment">//name = Peter, age = 18</span></span><br></pre></td></tr></table></figure><h2 id="Designated-Initializer和Convenience-Initializer"><a href="#Designated-Initializer和Convenience-Initializer" class="headerlink" title="Designated Initializer和Convenience Initializer"></a>Designated Initializer和Convenience Initializer</h2><p>Designated Initializer我们直译为指定构造器，这是class类型里面的主要构造器，我们平时写的构造器基本都是Designated Initializer，来看例子，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Peter"</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这就是Designated Initializer</span></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> personOne = <span class="type">Person</span>(name: <span class="string">"Peter"</span>, age: <span class="number">18</span>)<span class="comment">//name = Peter, age = 18</span></span><br></pre></td></tr></table></figure><p>同时，类类型里面还有Convenience Initializer，我们直译为便利构造器，它只能横向代理，也就是说在它的实现里，最后必须调用本类里其他的指定构造器。便利构造器很多时候是为了一些特殊的场景，为了方便初始化而创造出来的，他的实现是基于某个指定构造器的，所以最终必须要调用某个指定构造器。我们看例子，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Peter"</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这就是Designated Initializer</span></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这就是Convenience Initializer</span></span><br><span class="line">  <span class="keyword">convenience</span> <span class="keyword">init</span>(info: (<span class="type">String</span>, <span class="type">Int</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> infoName = info.<span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> infoAge = info.<span class="number">1</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(name: infoName, age: infoAge)<span class="comment">//调用指定构造器</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> personOne = <span class="type">Person</span>(info: (<span class="string">"Peter"</span>, <span class="number">18</span>))<span class="comment">//name = Peter, age = 18</span></span><br></pre></td></tr></table></figure><h2 id="通过class的继承来看swift的two-phase-process"><a href="#通过class的继承来看swift的two-phase-process" class="headerlink" title="通过class的继承来看swift的two-phase process"></a>通过class的继承来看swift的two-phase process</h2><h3 id="继承和代理规则"><a href="#继承和代理规则" class="headerlink" title="继承和代理规则"></a>继承和代理规则</h3><p>上面我们看到了class类型的指定构造器和便利构造器，还是比较简单的，但是如果刚刚的<code>Person</code>的类型又派生出多个子类，有了继承，那就变得稍稍复杂了。我们还是来看一下吧，我们看例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Peter"</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这就是Designated Initializer</span></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这就是Convenience Initializer</span></span><br><span class="line">  <span class="keyword">convenience</span> <span class="keyword">init</span>(info: (<span class="type">String</span>, <span class="type">Int</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> infoName = info.<span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> infoAge = info.<span class="number">1</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(name: infoName, age: infoAge)<span class="comment">//调用指定构造器</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> studentNumber: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Student</code>继承自<code>Person</code>，<code>因为没有实现任何指定构造方法，所以自动继承父类Person的指定构造方法</code>，这是swift中继承规则的第一条，第二条是，<code>如果派生类实现了父类的所有指定构造方法，无论是规则一继承实现还是重载实现，那么可以继承父类的所有便利构造方法</code>。上面的例子中，<code>Student</code>满足了这两个条件，所以它继承了父类所有的指定和便利构造方法。我们来试试，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> studentOne = <span class="type">Student</span>(name: <span class="string">"Peter"</span>, age: <span class="number">18</span>)<span class="comment">//Student可以调用父类的指定构造器</span></span><br><span class="line"><span class="keyword">let</span> studentTwo = <span class="type">Student</span>(info: (<span class="string">"Jack"</span>, <span class="number">20</span>))<span class="comment">//Student可以调用父类的便利构造器</span></span><br></pre></td></tr></table></figure><p>当然，我们也可以不继承父类的指定构造器，我们可以直接重载它，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> studentNumber: <span class="type">Int</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//重载父类指定构造器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.studentNumber = <span class="number">0</span></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, age: age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，上面的初始化<code>studentOne</code>和<code>studentTwo</code>依然是可行的，它符合swift的两条继承规则。但是重载父类指定构造器必须调用父类的指定构造器，也就是上述代码中的<code>super.init(name: name, age: age)</code>，这个也就是我们所说的纵向代理。指定构造器只能纵向代理。</p><p>同时我们也可以重载父类的便利构造方法，但是不用写<code>override</code>关键字，原因是便利构造器只能横向代理，也就是只能代理给本类的指定构造器，实际上并没有调用父类的同名便利构造方法，严格意义上来讲，重载父类便利构造方法不能算作重载，所以也就不用<code>override</code>关键字了。来看代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> studentNumber: <span class="type">Int</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//重载父类指定构造器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.studentNumber = <span class="number">0</span></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, age: age)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//‘重载’父类便利构造器，严格意义上不能称之为重载</span></span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(info: (<span class="type">String</span>, <span class="type">Int</span>)) &#123;</span><br><span class="line">        <span class="keyword">let</span> infoName = info.<span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> infoAge = info.<span class="number">1</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: infoName, age: infoAge)</span><br><span class="line">        <span class="keyword">self</span>.studentNumber = <span class="number">8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，让我们少许总结一下吧</p><blockquote><p>class中的继承规则</p></blockquote><p>1.如果子类没有实现任何指定构造方法，那么该子类会自动继承父类的所有指定构造方法。</p><p>2.如果子类实现了父类的所有指定构造方法，无论是通过规则一继承的，还是通过重载实现的，那么子类可以继承父类的所有便利构造方法。</p><blockquote><p>class的构造方法的代理规则（我们可以简称为：指定构造器必须纵向代理，便利构造器必须横向代理）</p></blockquote><p>1.一个指定构造方法必须调用它直接父类的构造方法。</p><p>2.一个便利构造方法必须调用本类的其他构造方法。</p><p>3.一个便利构造方法无论调用本类多少构造方法，最终必须调用一个指定构造方法。</p><p>我们来看一张图，就十分清晰明了了，<code>指定构造器必须纵向代理，便利构造器必须横向代理</code>如下：</p><p><img src="https://res.cloudinary.com/petershi/image/upload/v1530774621/initializerDelegation02_2x.png" alt="代理规则"></p><h3 id="two-phase-process"><a href="#two-phase-process" class="headerlink" title="two-phase process"></a>two-phase process</h3><p>two-phase process，我直译为两段式构造过程。那什么叫两段式构造过程，其实就是swift把创建一个实例类的过程分成了两步。</p><blockquote><p>第一步</p></blockquote><ul><li><p>class中的一个指定构造器或便利构造器被调用</p></li><li><p>这个实例的内存被分配，但是该内存还没有被初始化</p></li><li><p>class中的指定构造器给class中的所有存储属性赋值，并且这些存储属性的内存被初始化</p></li><li><p>本类中的指定构造器调用父类的指定构造器，让父类完成和本类一样的工作初始化所有存储属性</p></li><li><p>顺着继承链一直到达最顶层的父类，完成同样的操作</p></li><li><p>当所有父类均对自有的存储属性完成初始化操作，保证了所有存储属性有值，那么该实例被完全初始化，第一步也就完成了</p></li></ul><blockquote><p>第二步</p></blockquote><ul><li><p>从继承链的最顶层逐步往下，没个指定构造器都有机会进一步定制实例对象，现在没个构造器里可是使用<code>self</code>来修改属性或者调用实例方法等</p></li><li><p>最终，在这条链中的便利构造器有机会去进一步自定义实例对象，并且可以使用<code>self</code>关键字</p></li></ul><p>所以还记得我们上面举过的一个例子吗，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> studentNumber: <span class="type">Int</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//重载父类指定构造器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.studentNumber = <span class="number">0</span></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, age: age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们把上述代码指定构造器里的<code>self.studentNumber = 0</code>和<code>super.init(name: name, age: age)</code>这两行对调可以吗？我们试一下，代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> studentNumber: <span class="type">Int</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//重载父类指定构造器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, age: age)<span class="comment">//Property 'self.studentNumber' not initialized at super.init call</span></span><br><span class="line">      <span class="keyword">self</span>.studentNumber = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会立马报错<code>Property &#39;self.studentNumber&#39; not initialized at super.init call</code>，为什么，因为在两段式构造过程中，第一步要求派生类必须自下而上的完成存储属性的初始化，所以上述代码必须先将本类的<code>studentNumber</code>先初始化，然后调用父类指定构造器，让父类做相同工作。</p><p>同样的，便利构造器也必须在最终调用完指定构造器后，才能使用<code>self</code>来自定义实例对象，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">convenience</span> <span class="keyword">init</span>(info: (<span class="type">String</span>, <span class="type">Int</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> infoName = info.<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> infoAge = info.<span class="number">1</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(name: infoName, age: infoAge)<span class="comment">//必须先调用完指定构造器</span></span><br><span class="line">    <span class="keyword">self</span>.studentNumber = <span class="number">8</span><span class="comment">//然后才能自己自定义实例对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>struct和class的init构造方法是我们很常用的方法，不过里面也有非常多的细节和注意的地方，希望上述相关知识在你以后使用构造方法的时候能够帮上你的忙。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文相关知识参考了Apple官方的&lt;a href=&quot;https://docs.swift.org/swift-book/LanguageGuide/Initialization.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Swift文档&lt;/a&gt;
      
    
    </summary>
    
      <category term="swift" scheme="http://yoursite.com/categories/swift/"/>
    
    
      <category term="swift" scheme="http://yoursite.com/tags/swift/"/>
    
  </entry>
  
</feed>
