<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="NSLayoutAnchor基础知识"><meta name="keywords" content="iOS,swift"><meta name="author" content="Uncle Peter,undefined"><meta name="copyright" content="Uncle Peter"><title>NSLayoutAnchor基础知识 | Uncle Peter's Blog</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#UILayoutGuide"><span class="toc-number">1.</span> <span class="toc-text">UILayoutGuide</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#layoutMarginsGuide"><span class="toc-number">1.1.</span> <span class="toc-text">layoutMarginsGuide</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#safeAreaLayoutGuide"><span class="toc-number">1.2.</span> <span class="toc-text">safeAreaLayoutGuide</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#NSLayoutAnchor"><span class="toc-number">2.</span> <span class="toc-text">NSLayoutAnchor</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#NSLayoutAnchor简述"><span class="toc-number">2.1.</span> <span class="toc-text">NSLayoutAnchor简述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NSLayoutAnchor的API用法"><span class="toc-number">2.2.</span> <span class="toc-text">NSLayoutAnchor的API用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#继承自NSLayoutAnchor的共有API"><span class="toc-number">2.2.1.</span> <span class="toc-text">继承自NSLayoutAnchor的共有API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSLayoutXAxisAnchor的API"><span class="toc-number">2.2.2.</span> <span class="toc-text">NSLayoutXAxisAnchor的API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NSLayoutYAxisAnchor的API"><span class="toc-number">2.2.3.</span> <span class="toc-text">NSLayoutYAxisAnchor的API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NsLayoutDimension的API"><span class="toc-number">2.2.4.</span> <span class="toc-text">NsLayoutDimension的API</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#动手完整的实现一个代码布局"><span class="toc-number">3.</span> <span class="toc-text">动手完整的实现一个代码布局</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://res.cloudinary.com/petershi/image/upload/v1530082411/squareShotIcon.png"></div><div class="author-info__name text-center">Uncle Peter</div><div class="author-info__description text-center">Rome was not built in a day</div><div class="follow-button"><a href="https://github.com/chkkassd" target="_blank">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">9</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">3</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="http://blog.derekcoder.com" target="_blank">DerekCoder'sBlog</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://res.cloudinary.com/petershi/image/upload/v1530086666/timg-3.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">Uncle Peter's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">NSLayoutAnchor基础知识</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-01-28</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>我相信大家一直以来都是在Interface Builder里使用AutoLayout来添加约束，或者使用第三方库Masonry等来布局。确实在iOS9之前，如果不使用Interface Builder的话，用代码添加约束，很晦涩繁琐，好在有类似Masonry这些三方库。不过在iOS9之后，Apple似乎也意识到了这个问题，给我们开发者带来了NSLayoutAnchor这个类，这让我们以前用代码添加AutoLayout约束变得简洁明了很多。我个人甚至觉得使用NSLayoutAnchor来布局已经很方便，已经不想再使用Masonry。最近正好也看了相关Apple文档，所以想把NSLayoutAnchor相关知识整理于此，方便以后的翻阅。</p><h1 id="UILayoutGuide"><a href="#UILayoutGuide" class="headerlink" title="UILayoutGuide"></a>UILayoutGuide</h1><p>在讲述NSLayoutAnchor之前，我觉得我们有必要弄懂一些其他的概念，譬如UILayoutGuide等，因为这些在使用NSLayoutAnchor的时候都会用的到。</p><p>那什么是UILayoutGuide，其实它就是一个虚拟的矩形区域，可以和AutoLayout交互。它就像一个透明的view一样，但是不会被添加进视图层级，也不会拦截消息调用，它只是一个虚拟的矩形区域，为的就是和AutoLayout交互。譬如有时候你有这种需求：3个view排一行，互相之间的间隔相等。那么中间这个间隔就可以用UILayoutGudie来代替。</p><p>了解了这个概念后，我们需要了解我们后续会经常用到的view的两个属性：layoutMarginsGuide，safeAreaLayoutGuide，第一个出现于iOS9，后面那个属性出现于iOS11。</p><h2 id="layoutMarginsGuide"><a href="#layoutMarginsGuide" class="headerlink" title="layoutMarginsGuide"></a>layoutMarginsGuide</h2><p>layout margin：就是一个视图的内容和它四个边界之间的空隙，如下图：<img src="https://res.cloudinary.com/petershi/image/upload/v1535443804/4342a82a-4c29-4179-92c3-07ea170ba393.png" alt="layout margin"></p><p>view的layoutMarginsGuide属性，继承自UILayoutGuide，也是用来和AutoLayout交互的虚拟区域，代表的就是视图中内容和视图边界之间的间距区域。我们用代码编写AutoLayout约束的时候，可以以它作为参考对象设置约束。即便我们使用Interface Builder的时候，也可以选择是否基于margin设置约束，如下图：<img src="https://res.cloudinary.com/petershi/image/upload/v1535444793/7e6fb77b-4476-49a7-8bfc-0a57b9561af4.png" alt="constrain to margins"></p><p>当我们使用Interface Builder的时候，我们在storyboard里拖动一个view的的时候，当拖拽到离边界很近的时候，xcode会自动出现几条蓝色的辅助线，这个其实就是layoutMarginsGuide的区域，默认是左右各20，上下都是0，当然我们也可以手动修改layout margin的大小，如下图：<img src="https://res.cloudinary.com/petershi/image/upload/v1535444793/8d737388-3a04-4744-ab7d-13f2fad11840.png" alt="modify layout margin"></p><h2 id="safeAreaLayoutGuide"><a href="#safeAreaLayoutGuide" class="headerlink" title="safeAreaLayoutGuide"></a>safeAreaLayoutGuide</h2><p>在iOS11的时候，Apple提出了safe area的概念，因为有了iPhoneX，取消了home键，要为操作留一些空间，正好也把原来navigation bar，status bar，tab bar这些也都包含在里面，所以提出了安全区域的概念，在安全区域内设计你的App，绝对不会被导航栏等遮挡，顺势也推出了<code>safeAreaLayoutGuide</code>，这个view的属性，也是继承与UILayoutGuide，也是用来和AutoLayout交互用的，不过这个属性和上面的layoutMarginsGuide一样，都是只读属性，因为它们默认都已经先规定好了一个虚拟区域，我们可以直接基于它们，设置AutoLayout的约束。<img src="https://res.cloudinary.com/petershi/image/upload/v1535445522/e5aca39a-f9a2-4ab8-9f45-08fd95fb845c.png" alt="safeAreaLayoutGuide"></p><p>当然，如果有需要，我们可以根据具体情况来改变一个view的安全区域，要使用<code>additionalSafeAreaInsets</code>这个属性，这里就不展开了，一般而言我们无需自定义安全区域，除非我们自己设计了一些样式布局需要我们这么做。</p><h1 id="NSLayoutAnchor"><a href="#NSLayoutAnchor" class="headerlink" title="NSLayoutAnchor"></a>NSLayoutAnchor</h1><h2 id="NSLayoutAnchor简述"><a href="#NSLayoutAnchor简述" class="headerlink" title="NSLayoutAnchor简述"></a>NSLayoutAnchor简述</h2><p>现在我们来了解一下这个类，什么是NSLayoutAnchor，这个类可以通过一系列流畅的API，创建NSLayoutConstraint类型的约束对象，来进行布局约束的设置，而不用直接和NSLayoutConstraint对象打交道。</p><p>我们可以使用<code>UIView</code>，<code>NSView</code>或者<code>UILayoutGuide</code>，选择它们的一个anchor属性，然后调用对应的布局API来进行代码设置AutoLayout。这些anchor属性都是和<code>NSLayoutConstraint.Attribute</code>相对应的。但是，UIView的anchor属性里没有代表margin的属性，你会发现<code>NSLayoutConstraint.Attribute</code>里是有的，所以呢，表示margin其实就是用我们上述提到的<code>layoutMarginsGuide</code>来实现的。</p><p>我们来看个例子先，1是以前直接使用NSLayoutConstraint创建约束的代码。2是使用NSLayoutAnchor创建约束的代码</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.Creating constraints using NSLayoutConstraint</span></span><br><span class="line"><span class="type">NSLayoutConstraint</span>(item: subview,</span><br><span class="line">                   attribute: .leading,</span><br><span class="line">                   relatedBy: .<span class="built_in">equal</span>,</span><br><span class="line">                   toItem: view,</span><br><span class="line">                   attribute: .leadingMargin,</span><br><span class="line">                   multiplier: <span class="number">1.0</span>,</span><br><span class="line">                   constant: <span class="number">0.0</span>).isActive = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="type">NSLayoutConstraint</span>(item: subview,</span><br><span class="line">                   attribute: .trailing,</span><br><span class="line">                   relatedBy: .<span class="built_in">equal</span>,</span><br><span class="line">                   toItem: view,</span><br><span class="line">                   attribute: .trailingMargin,</span><br><span class="line">                   multiplier: <span class="number">1.0</span>,</span><br><span class="line">                   constant: <span class="number">0.0</span>).isActive = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.Creating the same constraints using Layout Anchors</span></span><br><span class="line"><span class="keyword">let</span> margins = view.layoutMarginsGuide</span><br><span class="line"></span><br><span class="line">subview.leadingAnchor.constraint(equalTo: margins.leadingAnchor).isActive = <span class="literal">true</span></span><br><span class="line">subview.trailingAnchor.constraint(equalTo: margins.trailingAnchor).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>很明显第二种方法，代码更简洁，也更易读，不仅如此，NSLayoutAnchor还会提供类型检查，能够帮助我们减少一些非法约束的创建，后面会讲到。</p><p>其实通常来讲，我们不会直接使用<code>NSLayoutAnchor</code>这个类，我们都是使用它的子类来进行操作的，它的三个子类如下：</p><ul><li><p><code>NSLayoutXAxisAnchor</code>：x轴方向的锚点，用来创建水平方向的约束</p></li><li><p><code>NSLayoutYAxisAnchor</code>：y轴方向的锚点，用来创建垂直方向的约束</p></li><li><p><code>NSLayoutDimension</code>：尺寸相关的锚点，用来创建尺寸相关的约束</p></li></ul><p>一般而言我们都是直接使用UIView或者UILayoutGuide的anchor属性来布局，所以这些属性都已经提前被归纳为上面3中子类中的一种。</p><p>其实UIView和UILayoutGuide它们的锚点属性如下：</p><table><thead><tr><th style="text-align:left">y轴方向的锚点属性</th><th style="text-align:left">x轴方向的锚点属性</th><th style="text-align:left">尺寸相关的锚点属性</th></tr></thead><tbody><tr><td style="text-align:left">bottomAnchor</td><td style="text-align:left">leadingAnchor</td><td style="text-align:left">heightAnchor</td></tr><tr><td style="text-align:left">centerYAnchor</td><td style="text-align:left">leftAnchor</td><td style="text-align:left">widthAnchor</td></tr><tr><td style="text-align:left">topAnchor</td><td style="text-align:left">trailingAnchor</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">firstBaselineAnchor(UIView有这个属性)</td><td style="text-align:left">rightAnchor</td><td style="text-align:left"></td></tr><tr><td style="text-align:left">lastBaselineAnchor(UIView有这个属性)</td><td style="text-align:left">centerXAnchor</td></tr></tbody></table><p>那到底这个Anchor是什么意思，这个词中文意思是“锚点“，譬如bottomAnchor，按照字面意思是底部锚点，其实就是代表这个view的底部边界的位置，因为这是一个NSLayoutYAxisAnchor属性，也就是只代表y轴方向上的位置，在y轴方向上，它就代表了这个view底部的边界，而无需考虑x轴方向位置。同理，centerYAnchor就表示当前view在y轴方向上居中的那个位置锚点，topAnchor就代表了view在y轴方向最上面的边界锚点。x轴方向锚点属性和尺寸相关锚点属性都是类似的。</p><p>这里要注意leadingAnchor和leftAnchor，trailingAnchor和rightAnchor。虽然它们有时候效果一样，但还是有很大区别的，leadingAnchor代表view最前面的边界锚点，如果在英文等阅读顺序从左往右的国家，那么leading就代表left，但是在中东阿拉伯语等国家，它们的阅读顺序是从右往左，那么leading就代表了right。然而，leftAnchor无论在哪种环境下，都只是表示在左边，所以尽量使用leadingAnchor和trailingAnchor而不要使用leftAnchor和rightAnchor。</p><p>一个view这么多位置锚点属性，差不多将这个view在x轴，y轴，长宽尺寸都已经标注了，标注一个view这么多位置，尺寸的锚点，就是为了和另外一个view对应的位置锚点或尺寸锚点交互，这样才能确定一个view的位置和尺寸。所以，所有的这些锚点属性，都是为了和其他view的锚点属性相交互，通过API产生约束，才能确定位置。并且y轴方向的锚点属性只能和y轴方向的锚点属性交互，x轴方向的锚点属性只能和x轴方向的锚点属性交互，尺寸的锚点属性只能和尺寸的锚点属性交互，这也是NSLayoutAnchor的API可以做类型检查的原因。</p><h2 id="NSLayoutAnchor的API用法"><a href="#NSLayoutAnchor的API用法" class="headerlink" title="NSLayoutAnchor的API用法"></a>NSLayoutAnchor的API用法</h2><h3 id="继承自NSLayoutAnchor的共有API"><a href="#继承自NSLayoutAnchor的共有API" class="headerlink" title="继承自NSLayoutAnchor的共有API"></a>继承自NSLayoutAnchor的共有API</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="function"><span class="keyword">func</span> <span class="title">constraint</span><span class="params">(equalTo anchor: NSLayoutAnchor&lt;AnchorType&gt;)</span></span> -&gt; <span class="type">NSLayoutConstraint</span></span><br></pre></td></tr></table></figure><p>这个API表示当前view的锚点属性和传入参数的锚点属性是一致的，最终返回的NSLayoutConstraint类型的约束对象，表示两个view的锚点属性相等一致，并且是相同类型的锚点属性。</p><p>看例子，譬如我们设置一个view的左边紧挨着左页边距（margin），那么其实就是需要在x轴方向上，这个view的leadingAnchor和页边距的leadingAnchor在同一个位置，所以让这两个锚点位置重合，也就是相等一致即可：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：使用NSLayoutConstraint</span></span><br><span class="line"><span class="type">NSLayoutConstraint</span>(item: subview,</span><br><span class="line">                   attribute: .<span class="type">Leading</span>,</span><br><span class="line">                   relatedBy: .<span class="type">Equal</span>,</span><br><span class="line">                   toItem: view,</span><br><span class="line">                   attribute: .<span class="type">LeadingMargin</span>,</span><br><span class="line">                   multiplier: <span class="number">1.0</span>,</span><br><span class="line">                   constant: <span class="number">0.0</span>).active = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二：使用constraintEqualToAnchor:</span></span><br><span class="line"><span class="keyword">let</span> margins = view.layoutMarginsGuide</span><br><span class="line">subview.leadingAnchor.constraintEqualToAnchor(margins.leadingAnchor).active = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>注意的一点是，调用完NSLayoutAnchor的API以后，返回的是一个NSLayoutConstraint类型的约束对象，必须设置它的<code>active</code>属性为true，才是真正让这个约束生效。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>. <span class="function"><span class="keyword">func</span> <span class="title">constraint</span><span class="params">(equalTo anchor: NSLayoutAnchor&lt;AnchorType&gt;, </span></span></span><br><span class="line"><span class="function"><span class="params">       constant <span class="built_in">c</span>: CGFloat)</span></span> -&gt; <span class="type">NSLayoutConstraint</span></span><br></pre></td></tr></table></figure><p>这个API的意思可以用一个公式表达：调用此方法的view的锚点属性 = 参数view的锚点属性 + 常量值c。</p><ul><li><p>对于NSLayoutXAxisAnchor类型的属性来说，表示在x轴方向上，调用此方法的view位置在参数view的位置后面，距离为c。</p></li><li><p>对于NSLayoutYAxisAnchor类型的属性来说，表示在Y轴方向上，调用此方法的view位置在参数view的位置下面，距离为c。</p></li><li><p>对于NSLayoutDimension类型的属性来说，表示调用此方法的view尺寸比参数view的对应尺寸大c。</p></li></ul><p>继续看之前那个例子，现在我们希望subview的左边界不再紧挨着左页边距，而是和左页边距距离8：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> margins = view.layoutMarginsGuide</span><br><span class="line">subview.leadingAnchor.constraintEqualToAnchor(margins.leadingAnchor, constant: <span class="number">8.0</span>).active = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>这样子，subview在x轴方向上就会里页面的左页边距始终距离8。</p><h3 id="NSLayoutXAxisAnchor的API"><a href="#NSLayoutXAxisAnchor的API" class="headerlink" title="NSLayoutXAxisAnchor的API"></a>NSLayoutXAxisAnchor的API</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="function"><span class="keyword">func</span> <span class="title">constraint</span><span class="params">(equalToSystemSpacingAfter anchor: NSLayoutXAxisAnchor, </span></span></span><br><span class="line"><span class="function"><span class="params">     multiplier: CGFloat)</span></span> -&gt; <span class="type">NSLayoutConstraint</span></span><br></pre></td></tr></table></figure><p>这个API的意思可以用一个公式表达：调用此方法的view的锚点属性 = 参数view的锚点属性 + 系统默认间距*multiplier。</p><p>其实就是在x轴方向上，调用此方法的view的位置在参数view的后面，距离是系统默认间距*multiplier。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>. <span class="function"><span class="keyword">func</span> <span class="title">anchorWithOffset</span><span class="params">(to otherAnchor: NSLayoutXAxisAnchor)</span></span> -&gt; <span class="type">NSLayoutDimension</span></span><br></pre></td></tr></table></figure><p>这个API的意思是，在x轴方向上，调用此方法的NSLayoutXAxisAnchor类型锚点和同类型参数锚点之间的间距，并以NSLayoutDimension类型返回。说白了，就是利用两个view在x轴方向上，传入锚点的距离，生成了一个尺寸锚点，这个尺寸锚点可以用来自定义一些布局之类的。</p><h3 id="NSLayoutYAxisAnchor的API"><a href="#NSLayoutYAxisAnchor的API" class="headerlink" title="NSLayoutYAxisAnchor的API"></a>NSLayoutYAxisAnchor的API</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="function"><span class="keyword">func</span> <span class="title">constraint</span><span class="params">(equalToSystemSpacingBelow anchor: NSLayoutYAxisAnchor, </span></span></span><br><span class="line"><span class="function"><span class="params">     multiplier: CGFloat)</span></span> -&gt; <span class="type">NSLayoutConstraint</span></span><br></pre></td></tr></table></figure><p>这个API的意思可以用一个公式表达：调用此方法的view的锚点属性 = 参数view的锚点属性 + 系统默认间距*multiplier。</p><p>其实就是在Y轴方向上，调用此方法的view的位置在参数view的下面，距离是系统默认间距*multiplier。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>. <span class="function"><span class="keyword">func</span> <span class="title">anchorWithOffset</span><span class="params">(to otherAnchor: NSLayoutYAxisAnchor)</span></span> -&gt; <span class="type">NSLayoutDimension</span></span><br></pre></td></tr></table></figure><p>和NSLayoutXAxisAnchor的API类似，在Y轴方向上，调用此方法的NSLayoutYAxisAnchor类型锚点和同类型参数锚点之间的间距，并以NSLayoutDimension类型返回。说白了，就是利用两个view在Y轴方向上，传入锚点的距离，生成了一个尺寸锚点，这个尺寸锚点可以用来自定义一些布局之类的。</p><h3 id="NsLayoutDimension的API"><a href="#NsLayoutDimension的API" class="headerlink" title="NsLayoutDimension的API"></a>NsLayoutDimension的API</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="function"><span class="keyword">func</span> <span class="title">constraint</span><span class="params">(equalTo anchor: NSLayoutDimension, </span></span></span><br><span class="line"><span class="function"><span class="params">     multiplier m: CGFloat)</span></span> -&gt; <span class="type">NSLayoutConstraint</span></span><br></pre></td></tr></table></figure><p>这个API的意思可以用一个公式表达：调用此方法的view的尺寸锚点属性 = 参数view的尺寸锚点属性 * m。</p><p>看个例子，比如我们有两个view，一个redview，一个blueview，其中blueview的宽是redview的2倍，这样的布局需求很常见把，看代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blueview.widthAnchor.constraint(equalTo: redview.widthAnchor, multiplier: <span class="number">2.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>. <span class="function"><span class="keyword">func</span> <span class="title">constraint</span><span class="params">(equalTo anchor: NSLayoutDimension, </span></span></span><br><span class="line"><span class="function"><span class="params">     multiplier m: CGFloat, </span></span></span><br><span class="line"><span class="function"><span class="params">       constant <span class="built_in">c</span>: CGFloat)</span></span> -&gt; <span class="type">NSLayoutConstraint</span></span><br></pre></td></tr></table></figure><p>这个API的意思可以用一个公式表达：调用此方法的view的尺寸锚点属性 = 参数view的尺寸锚点属性 * m + 常量c。</p><p>继续看上面的例子，现在我们希望blueview的宽是redview的2倍还要多10，那么代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blueview.widthAnchor.constraint(equalTo: redview.widthAnchor, multiplier: <span class="number">2.0</span>, constant: <span class="number">10.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>. <span class="function"><span class="keyword">func</span> <span class="title">constraint</span><span class="params">(equalToConstant <span class="built_in">c</span>: CGFloat)</span></span> -&gt; <span class="type">NSLayoutConstraint</span></span><br></pre></td></tr></table></figure><p>这个就很简单了，就是调用此方法的view的尺寸锚点属性 = 常量c。就是我们通常需要固定一个view的宽高为常量值，那么就用这个API。譬如我们固定上述例子里，blueview的宽为50，代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blueview.widthAnchor.constraint(equalToConstant: <span class="number">50.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="动手完整的实现一个代码布局"><a href="#动手完整的实现一个代码布局" class="headerlink" title="动手完整的实现一个代码布局"></a>动手完整的实现一个代码布局</h1><p>我们回过头来看一下，为什么Apple会设计NSLayoutAnchor的三个不同子类，其实，确定一个view的位置，恰恰就是确定x轴方向的位置，y轴方向的位置，然后就是宽高尺寸。这三个要素一确定，那么这个视图的布局也就确定了，所以我们在用代码写视图布局的时候，也就是考虑这三个方面，x轴方向位置是否确定了？y轴方向位置是否确定了？宽高尺寸是否确定了？说了这么多，我们来自己动手练一下把。</p><p>假设我们现在有这样的布局需求，两个view，一个红色的view，一个绿色的view，这两个view左右排列，撑满整个屏幕，但是离屏幕的边界（不是内容边距margin）都有20的间隙，两个view之间相隔8，并且绿色的view宽度是红色view的两倍。</p><p>如果我们直接在Interface Builder里设置约束，可以很快实现，但有时候，无法使用Interface Builder，那么我们就需要使用代码来布局了。</p><p>注意一点，如果我们需要对一个view使用代码进行AutoLayout设置，我们需要将它的<code>translatesAutoresizingMaskIntoConstraints</code>属性设为false。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">redView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line">greenView.translatesAutoresizingMaskIntoConstraints = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取安全区域的layoutGudie      </span></span><br><span class="line"><span class="keyword">let</span> safeArea = <span class="keyword">self</span>.view.safeAreaLayoutGuide</span><br><span class="line"></span><br><span class="line"><span class="comment">//Y轴方向布局</span></span><br><span class="line">redView.topAnchor.constraint(equalTo: safeArea.topAnchor, constant: <span class="number">20.0</span>).isActive = <span class="literal">true</span></span><br><span class="line">safeArea.bottomAnchor.constraint(equalTo:redView.bottomAnchor , constant: <span class="number">20.0</span>).isActive = <span class="literal">true</span></span><br><span class="line">greenView.topAnchor.constraint(equalTo: safeArea.topAnchor, constant: <span class="number">20.0</span>).isActive = <span class="literal">true</span></span><br><span class="line">safeArea.bottomAnchor.constraint(equalTo: greenView.bottomAnchor, constant: <span class="number">20.0</span>).isActive = <span class="literal">true</span></span><br><span class="line"><span class="comment">//X轴方向布局</span></span><br><span class="line">redView.leadingAnchor.constraint(equalTo: safeArea.leadingAnchor, constant: <span class="number">20.0</span>).isActive = <span class="literal">true</span></span><br><span class="line">greenView.leadingAnchor.constraint(equalTo: redView.trailingAnchor, constant: <span class="number">8.0</span>).isActive = <span class="literal">true</span></span><br><span class="line">safeArea.trailingAnchor.constraint(equalTo: greenView.trailingAnchor, constant:<span class="number">20.0</span>).isActive = <span class="literal">true</span></span><br><span class="line"><span class="comment">//尺寸相关的布局</span></span><br><span class="line">greenView.widthAnchor.constraint(equalTo: redView.widthAnchor, multiplier: <span class="number">2.0</span>).isActive = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><img src="https://res.cloudinary.com/petershi/image/upload/v1535531116/NsLayoutAnchor.png" alt="布局效果图"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>NSLayoutAnchor相关知识就介绍到此，对于我们平常iOS开发而言，能使用Interfac Builder设置约束那就最好了，如果某些情况下需要代码来设置约束，使用AutoLayout，那么NSLayoutAnchor可以能够帮我们很大的忙，比起原来直接创建NSLayoutConstraint对象，要方便且易读很多。以上记录是我的一些学习心得，方便自己和有需要的同学参考，详尽知识还请参考<a href="https://developer.apple.com/documentation/uikit/view_layout" target="_blank" rel="noopener">Apple官方文档</a>。</p></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Uncle Peter</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/01/28/NSLayoutAnchor基础知识/">http://yoursite.com/2018/01/28/NSLayoutAnchor基础知识/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a><a class="post-meta__tags" href="/tags/swift/">swift</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/02/26/swift中map与flatMap的用法与研究/"><i class="fa fa-chevron-left"></i><span>swift中map与flatMap的用法与研究</span></a></div><div class="next-post pull-right"><a href="/2018/01/08/iOS自动布局基础知识/"><span>iOS自动布局基础知识</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2018 By Uncle Peter</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Welcome to my blog,have a nice day.</div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>