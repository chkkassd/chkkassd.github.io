<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="swift中map与flatMap的用法与研究"><meta name="keywords" content="swift,函数式编程"><meta name="author" content="Uncle Peter,undefined"><meta name="copyright" content="Uncle Peter"><title>swift中map与flatMap的用法与研究 | Uncle Peter</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#map和flatMap用法"><span class="toc-number">1.</span> <span class="toc-text">map和flatMap用法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#map和flatMap在标准库中的实现"><span class="toc-number">2.</span> <span class="toc-text">map和flatMap在标准库中的实现</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数式编程"><span class="toc-number">3.</span> <span class="toc-text">函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#封装值"><span class="toc-number">3.1.</span> <span class="toc-text">封装值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Functor"><span class="toc-number">3.2.</span> <span class="toc-text">Functor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Monad"><span class="toc-number">3.3.</span> <span class="toc-text">Monad</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#用函数式思想解决网络请求问题"><span class="toc-number">3.4.</span> <span class="toc-text">用函数式思想解决网络请求问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">4.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://res.cloudinary.com/petershi/image/upload/v1530082411/squareShotIcon.png"></div><div class="author-info__name text-center">Uncle Peter</div><div class="author-info__description text-center">不积硅步无以至千里</div><div class="follow-button"><a href="https://github.com/chkkassd" target="_blank">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">3</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">2</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">1</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="http://blog.derekcoder.com" target="_blank">DerekCoder'sBlog</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://res.cloudinary.com/petershi/image/upload/v1530086666/timg-3.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">Uncle Peter</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">swift中map与flatMap的用法与研究</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-02-26</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/swift/">swift</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p><code>map</code>和<code>flatMap</code>是swift中两个高阶函数，用处很大，其实不仅仅是这两个函数，其他的譬如<code>reduce</code>，<code>filter</code>等等，都为我们提供了很多功能，是之前在oc里无法提供，或者需要自己去实现的。当然这些函数在其他语言里是一直存在的，譬如<code>Haskell</code>。所以<code>swift</code>是一门多编程范式的语言，这里只是记录一下<code>map</code>和<code>flatMap</code>的用法，以及通过这个，我们来看一下函数式思想在<code>swfit</code>中的运用。</p><h1 id="map和flatMap用法"><a href="#map和flatMap用法" class="headerlink" title="map和flatMap用法"></a>map和flatMap用法</h1><p>我们直接看例子：</p><blockquote><p>例1 数组中使用</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = arr.<span class="built_in">map</span> &#123;$<span class="number">0</span> + <span class="number">1</span>&#125;<span class="comment">//[2,3,4],将数组中每一个整数加一然后返回,返回值类型是Array</span></span><br><span class="line"><span class="keyword">let</span> arr3 = arr.flatMap &#123;[$<span class="number">0</span> - <span class="number">1</span>, $<span class="number">0</span> + <span class="number">1</span>]&#125;<span class="comment">//[0, 2, 1, 3, 2, 4]，将数组中每一个整型元素映射成了一个数组，如果用map将会得到一个二维数组，所以用flatmap降维成一维数组</span></span><br></pre></td></tr></table></figure><blockquote><p>例2 数组的<code>flatMap</code>(在swift4.1中，已经改名为compactMap,下面的源码也贴了出来)还有另外一种用法</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> brr = [<span class="string">"1"</span>, <span class="string">"2"</span>,<span class="string">"三"</span>, <span class="string">"4"</span>]</span><br><span class="line"><span class="comment">//let brr2 = brr.compactMap &#123;Int($0)&#125;</span></span><br><span class="line"><span class="keyword">let</span> brr2 = brr.flatMap &#123;<span class="type">Int</span>($<span class="number">0</span>)&#125;<span class="comment">//[1, 2, 4],Int()函数将String转成Int类型，有可能成功，也有可能失败，所以返回值类型是Optional&lt;Int&gt;,很明显这边数组brr里的"三"是无法成功转换成整型3的，所以返回nil，结果是[1,2,nil,4],此时的flatMap可以过滤掉了nil</span></span><br></pre></td></tr></table></figure><p>因为这个<code>flatMap</code>除了 降维之外其实还有 filter 的作用，在使用时容易产生歧义，所以社区认为最好把这个flatMap重新拆分出来，使用一个新的方法命名，所以就有了<code>compactMap</code>。</p><blockquote><p>例3 <code>optional</code>中使用</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str: <span class="type">String</span>? = <span class="string">"12"</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = str.<span class="built_in">map</span> &#123;$<span class="number">0</span>.<span class="built_in">count</span>&#125;<span class="comment">//count = 2,如果这个str有值，就计算这个string的字符个数，如果没有值，就返回nil，注意count的类型为Optional&lt;Int&gt;</span></span><br><span class="line"><span class="keyword">let</span> value = str.flatMap &#123;<span class="type">Int</span>($<span class="number">0</span>)&#125;<span class="comment">//value = 12,和上面数组中使用一样，Int()函数将String转成Int类型，有可能成功，也有可能失败，所以返回值类型是Optional&lt;Int&gt;，此时如果使用map，那么value返回的类型会变成Optional&lt;Optional&lt;Int&gt;&gt;，嵌套的optional，所以使用flatMap，其实也是降维的概念，使其返回类型变为Optional&lt;Int&gt;。</span></span><br></pre></td></tr></table></figure><h1 id="map和flatMap在标准库中的实现"><a href="#map和flatMap在标准库中的实现" class="headerlink" title="map和flatMap在标准库中的实现"></a>map和flatMap在标准库中的实现</h1><p>没有什么比看源码更能直接了当的了解一个类或者方法了，大家也可以直接去<a href="https://github.com/apple/swift/tree/master/stdlib/public/core" target="_blank" rel="noopener">swift源码</a>查看。我们会发现，<code>sequence</code>和<code>optional</code>都实现了这两个方法，如下所示：</p><blockquote><p><code>sequence</code>中<code>map</code>和<code>flatMap</code> 的实现</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">T</span></span><br><span class="line">  ) <span class="keyword">rethrows</span> -&gt; [<span class="type">T</span>] &#123;</span><br><span class="line">    <span class="keyword">let</span> initialCapacity = underestimatedCount</span><br><span class="line">    <span class="keyword">var</span> result = <span class="type">ContiguousArray</span>&lt;<span class="type">T</span>&gt;()</span><br><span class="line">    result.reserveCapacity(initialCapacity)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> iterator = <span class="keyword">self</span>.makeIterator()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add elements up to the initial capacity without checking for regrowth.</span></span><br><span class="line">    <span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;initialCapacity &#123;</span><br><span class="line">      result.append(<span class="keyword">try</span> transform(iterator.next()!))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Add remaining elements, if any.</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> element = iterator.next() &#123;</span><br><span class="line">      result.append(<span class="keyword">try</span> transform(element))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Array</span>(result)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;SegmentOfResult : Sequence&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">SegmentOfResult</span></span><br><span class="line">  ) <span class="keyword">rethrows</span> -&gt; [<span class="type">SegmentOfResult</span>.<span class="type">Element</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> result: [<span class="type">SegmentOfResult</span>.<span class="type">Element</span>] = []</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">      result.append(contentsOf: <span class="keyword">try</span> transform(element))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;ElementOfResult&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">ElementOfResult</span>?</span><br><span class="line">  ) <span class="keyword">rethrows</span> -&gt; [<span class="type">ElementOfResult</span>] &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> _compactMap(transform)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">_compactMap</span>&lt;ElementOfResult&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> transform: <span class="params">(Element)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">ElementOfResult</span>?</span><br><span class="line">  ) <span class="keyword">rethrows</span> -&gt; [<span class="type">ElementOfResult</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> result: [<span class="type">ElementOfResult</span>] = []</span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> <span class="keyword">let</span> newElement = <span class="keyword">try</span> transform(element) &#123;</span><br><span class="line">        result.append(newElement)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>optional</code>中<code>map</code>和<code>flatMap</code>的实现</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> transform: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">U</span></span><br><span class="line">  ) <span class="keyword">rethrows</span> -&gt; <span class="type">U</span>? &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .some(<span class="keyword">let</span> y):</span><br><span class="line">      <span class="keyword">return</span> .some(<span class="keyword">try</span> transform(y))</span><br><span class="line">    <span class="keyword">case</span> .<span class="keyword">none</span>:</span><br><span class="line">      <span class="keyword">return</span> .<span class="keyword">none</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;U&gt;<span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="number">_</span> transform: <span class="params">(Wrapped)</span></span></span> <span class="keyword">throws</span> -&gt; <span class="type">U</span>?</span><br><span class="line">  ) <span class="keyword">rethrows</span> -&gt; <span class="type">U</span>? &#123;</span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> .some(<span class="keyword">let</span> y):</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">try</span> transform(y)</span><br><span class="line">    <span class="keyword">case</span> .<span class="keyword">none</span>:</span><br><span class="line">      <span class="keyword">return</span> .<span class="keyword">none</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>看完源码实现，大家就能够明白上面的用法了，这里就不赘述了，不过我们需要透过现象看本质，看一看Apple到底为什么要这样来设计，他的思想是什么。</p><p>所以，我们来捋一捋，去掉各种不重要的符号，以及<code>sequence</code>中第二个版本的<code>flatMap</code>已经更名为<code>compactMap</code>,表意更清晰，所以也不会混淆了，所以也暂时去掉他，那么<code>sequence</code>和<code>optional</code>中的定义如下：</p><blockquote><p><code>sequence</code>:</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;T&gt;<span class="params">(transform: <span class="params">(Element)</span></span></span> -&gt; <span class="type">T</span>) -&gt; [<span class="type">T</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;SegmentOfResult : Sequence&gt;<span class="params">(transform: <span class="params">(Element)</span></span></span> -&gt; <span class="type">SegmentOfResult</span>) -&gt; [<span class="type">SegmentOfResult</span>.<span class="type">Element</span>]</span><br></pre></td></tr></table></figure><blockquote><p><code>optional</code>:</p></blockquote><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(transform: <span class="params">(Wrapped)</span></span></span> -&gt; <span class="type">U</span>) -&gt; <span class="type">U</span>?</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;U&gt;<span class="params">(transform: <span class="params">(Wrapped)</span></span></span> -&gt; <span class="type">U</span>?) -&gt; <span class="type">U</span>?</span><br></pre></td></tr></table></figure><p>我们会发现，<code>sequence</code>中<code>map</code>与<code>flatMap</code>方法的区别主要在于transform方法，一个将element转换为<code>T</code>类型，一个将element转换为<code>sequence</code>类型</p><p>同理，<code>optional</code>中<code>map</code>与<code>flatMap</code>方法的区别主要也在于transform方法，一个将解包后的值转换为<code>U</code>类型，一个将解包后的值转换为<code>U?</code>类型。</p><p>为什么<code>sequence</code>和<code>optional</code>都有这两个方法，有什么关联吗，这个需要我们来了解一下函数式编程一些知识。</p><h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><p>其实很难给出函数式的准确定义，不过有几个概念是函数式编程中经常会遇到的，<code>Functor</code>，<code>Applicative</code>和<code>Monad</code>，之前对这个了解也不是很深，直到后面看到一篇文章，讲的很通俗易懂，想看小伙伴可以点击<a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="noopener">这里</a>来查看原文。</p><h2 id="封装值"><a href="#封装值" class="headerlink" title="封装值"></a>封装值</h2><p>其实这里有一个封装值的概念，我们在编程的时候用到很多基础类型值，譬如3就是一个整型，但是包装值的概念是将整型3放入其中，将其封装起来，对外表现出的类型已经不是整型，可以是其他类型，<code>swift</code>中有一个绝佳的例子<code>enum</code>的Associated Value 如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> success(<span class="type">T</span>)</span><br><span class="line">  <span class="keyword">case</span> fail</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="type">Result</span>.success(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>如上所示，整型3被封装了起来，对外的类型是<code>enum</code>，这就是封装值的概念，下面的诸多例子我们都会用这个<code>Result</code>来演示。</p><p>其实<code>optional</code>就是用<code>enum</code>来实现的如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Optional</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">None</span></span><br><span class="line">  <span class="keyword">case</span> <span class="type">Some</span>(<span class="type">T</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以大家该明白了，<code>optional</code>就是一种封装值。</p><h2 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h2><p>我们平时写代码用的最多的函数是处理普通值函数的代码，譬如如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(<span class="number">_</span> number: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = addOne(a)<span class="comment">//b = 2</span></span><br></pre></td></tr></table></figure><p>但是，如果我们把上述的整型a变成封装值，上述的<code>addOne()</code>函数就无法工作了，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="type">Result</span>.success(<span class="number">1</span>)<span class="comment">//a已经变成了一个封装值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(<span class="number">_</span> number: Int)</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = addOne(a)<span class="comment">//报错，提示a类型不是Int类型</span></span><br></pre></td></tr></table></figure><p>这时候，我们就需要将封装值从它封装的类型<code>Result</code>里拿出来，再传给<code>addOne()</code>函数，才能正常工作，然后将通过<code>addOne()</code>函数计算好后得到的普通结果值再次封装在<code>Result</code>里，返回这个封装结果值，这个过程就是<code>Functor</code>.</p><p>我们来实现这个<code>Functor</code>，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">functor</span><span class="params">(<span class="number">_</span> result: Result&lt;Int&gt;, transform: <span class="params">(Int)</span></span></span>-&gt; <span class="type">Int</span>) -&gt; <span class="type">Result</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .success(value):</span><br><span class="line">        <span class="keyword">return</span> .success(transform(value))</span><br><span class="line">    <span class="keyword">case</span> .fail:</span><br><span class="line">        <span class="keyword">return</span> .fail</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = functor(a, transform: addOne)<span class="comment">//b = .success(2)</span></span><br></pre></td></tr></table></figure><p>如果大家把这个<code>functor</code>函数和上面源码中<code>sequence</code>和<code>optional</code>中<code>map</code>方法的实现比照，就会发现，<code>sequence</code>和<code>optional</code>中的<code>map</code>方法就是<code>Functor</code>思想在<code>swift</code>中的实现，有同学会说<code>sequence</code>中的<code>map</code>好像不是啊，其实如果把数组也看作一种封装值，那就是一样的啦。</p><p><img src="https://i.loli.net/2018/06/28/5b349e05a1db4.jpg" alt="5b349e05a1db4"></p><h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><p>继续上面的例子，如果我们不仅仅a变成封装值，我们的<code>addOne()</code>函数的返回值不再是<code>Int</code>,而是一个封装值，譬如<code>Result&lt;Int&gt;</code>，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addOne</span><span class="params">(<span class="number">_</span> number: Int)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Result</span>.success(number + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那整个计算过程就需要少许改变一下了，因为我们现在的<code>addOne()</code>函数也返回封装值，如果在用刚刚的<code>functor</code>函数，那返回值就会出现封装值里面嵌套封装值，啊，这绝对是我们不想看到的，我们来修改一下<code>functor</code>函数，取个新函数名<code>monad</code>如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">monad</span><span class="params">(<span class="number">_</span> result: Result&lt;Int&gt;, transform: <span class="params">(Int)</span></span></span>-&gt; <span class="type">Result</span>&lt;<span class="type">Int</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">Int</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> result &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="keyword">let</span> .success(value):</span><br><span class="line">        <span class="keyword">return</span> transform(value)</span><br><span class="line">    <span class="keyword">case</span> .fail:</span><br><span class="line">        <span class="keyword">return</span> .fail</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = monad(a, transform: addOne)<span class="comment">//c = .success(2)</span></span><br></pre></td></tr></table></figure><p>如果大家把这个<code>monad</code>函数和上面源码中<code>sequence</code>和<code>optional</code>中<code>flatMap</code>方法的实现比照，就会发现，<code>sequence</code>和<code>optional</code>中的<code>flatMap</code>方法就是<code>Monad</code>思想在<code>swift</code>中的实现。</p><p>但是<code>Monad</code>绝对不仅仅是降维这么简单，它真正厉害的地方是可以将多个函数串联起来，将原来一个完整的流程拆分为多个函数的串联，每个函数完成一个单独的功能，串联起来实现一个复杂的功能，我觉得<code>Monad</code>不单单是个函数，更多的是一种思想，一种解决问题的思路。</p><p>我们看一个用这个思想解决的一个问题。</p><h2 id="用函数式思想解决网络请求问题"><a href="#用函数式思想解决网络请求问题" class="headerlink" title="用函数式思想解决网络请求问题"></a>用函数式思想解决网络请求问题</h2><p>大家经常遇到这样的需求，判断有没有网络-&gt;获取接口数据成功与否-&gt;解析数据成功与否-&gt;保存数据成功与否，为了演示，我写了几个函数如下方便大家理解：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkNet</span><span class="params">()</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Bool</span>&gt;<span class="comment">//检查网络</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fetchData</span><span class="params">(canFetch: Bool)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Data</span>&gt;<span class="comment">//获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseData</span><span class="params">(data: Data)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">Dictionary</span>&gt;<span class="comment">//解析数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saveData</span><span class="params">(diationary: Dictionary)</span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">String</span>&gt;<span class="comment">//保存数据</span></span><br></pre></td></tr></table></figure><p>我们以前常用的做法是if判断，肯定没问题，但是如果我们尝试用上面提到的函数式思想去考虑的话也许就有更好的方法。</p><p>下面是我自己写的常用的一个用以处理结果的类，并将<code>map</code>和<code>flatMap</code>的操作自定义成一个操作符，方便串连调用，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="comment">///This enumuration describes the result of all situation.</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Result</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> success(<span class="type">T</span>)</span><br><span class="line">    <span class="keyword">case</span> failure(<span class="type">Error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="comment">///Functor</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">map</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .success(<span class="keyword">let</span> v):</span><br><span class="line">            <span class="keyword">return</span> .success(transform(v))</span><br><span class="line">        <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">            <span class="keyword">return</span> .failure(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///Applicative</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">apply</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transform: Result&lt;<span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> transform &#123;</span><br><span class="line">        <span class="keyword">case</span> .success(<span class="keyword">let</span> function):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">self</span>.<span class="built_in">map</span>(function)</span><br><span class="line">        <span class="keyword">case</span> .failure(<span class="keyword">let</span> error):</span><br><span class="line">            <span class="keyword">return</span> .failure(error)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">///Monad</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">flatMap</span>&lt;U&gt;<span class="params">(<span class="number">_</span> transform: <span class="params">(T)</span></span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">switch</span> <span class="keyword">self</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> .success(<span class="keyword">let</span> v):</span><br><span class="line">            <span class="keyword">return</span> transform(v)</span><br><span class="line">        <span class="keyword">case</span> .failure(<span class="keyword">let</span> e):</span><br><span class="line">            <span class="keyword">return</span> .failure(e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">precedencegroup <span class="type">ChainingPrecedence</span> &#123;</span><br><span class="line">    <span class="keyword">associativity</span>: <span class="keyword">left</span></span><br><span class="line">    higherThan: <span class="type">TernaryPrecedence</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///Functor</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &lt;^&gt;: <span class="type">ChainingPrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> &lt;^&gt;&lt;T, U&gt;<span class="params">(lhs: <span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>, rhs: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs.<span class="built_in">map</span>(lhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///Applicative</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &lt;*&gt;: <span class="type">ChainingPrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> &lt;*&gt;&lt;T, U&gt;<span class="params">(lhs: Result&lt;<span class="params">(T)</span></span></span> -&gt; <span class="type">U</span>&gt;, rhs: <span class="type">Result</span>&lt;<span class="type">T</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> rhs.apply(lhs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///Monad</span></span><br><span class="line"><span class="keyword">infix</span> <span class="keyword">operator</span> &gt;&gt;-: <span class="type">ChainingPrecedence</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> &gt;&gt;-&lt;T, U&gt;<span class="params">(lhs: Result&lt;T&gt;, rhs: <span class="params">(T)</span></span></span> -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt;) -&gt; <span class="type">Result</span>&lt;<span class="type">U</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.flatMap(rhs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那这个问题可以简单的这样处理 ，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = checkNet()&gt;&gt;-fetchData&gt;&gt;-parseData&gt;&gt;-saveData</span><br></pre></td></tr></table></figure><p>哪一个步骤出错了，错误信息也都能捕捉到，所以这样子是不是就是简单了好多，代码优雅了好多。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>swift</code> 是一门多编程范式语言，对于函数式编程的思想集成的很好，标准库已经实现了很多高阶函数，<code>FP</code>思想很多时候能在一些问题的处理上带给我们不同的思路和解决方法，希望以上的信息能够帮到你，谢谢。</p></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Uncle Peter</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2018/02/26/swift中map与flatMap的用法与研究/">http://yoursite.com/2018/02/26/swift中map与flatMap的用法与研究/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/swift/">swift</a><a class="post-meta__tags" href="/tags/函数式编程/">函数式编程</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/03/05/swift中copy on write的研究/"><i class="fa fa-chevron-left"></i><span>swift中copy on write的研究</span></a></div><div class="next-post pull-right"><a href="/2017/07/04/swift中的Initialization/"><span>swift中的Initialization</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2018 By Uncle Peter</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Welcome to my blog,have a nice day.</div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>