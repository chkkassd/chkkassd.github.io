<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="ios中UIScrollView的基础知识"><meta name="keywords" content="iOS,swift"><meta name="author" content="Uncle Peter,undefined"><meta name="copyright" content="Uncle Peter"><title>ios中UIScrollView的基础知识 | Uncle Peter's Blog</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#UIScrollView介绍"><span class="toc-number">1.</span> <span class="toc-text">UIScrollView介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UIScrollView的属性和相关API"><span class="toc-number">2.</span> <span class="toc-text">UIScrollView的属性和相关API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#响应scroll-view交互"><span class="toc-number">2.1.</span> <span class="toc-text">响应scroll view交互</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#管理内容尺寸和偏移"><span class="toc-number">2.2.</span> <span class="toc-text">管理内容尺寸和偏移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#管理内容嵌入的行为"><span class="toc-number">2.3.</span> <span class="toc-text">管理内容嵌入的行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取布局指南"><span class="toc-number">2.4.</span> <span class="toc-text">获取布局指南</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对scrollVIew的配置构造"><span class="toc-number">2.5.</span> <span class="toc-text">对scrollVIew的配置构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#获取滚动状态"><span class="toc-number">2.6.</span> <span class="toc-text">获取滚动状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#管理滚动指示器和刷新控制"><span class="toc-number">2.7.</span> <span class="toc-text">管理滚动指示器和刷新控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#管理触摸"><span class="toc-number">2.8.</span> <span class="toc-text">管理触摸</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#缩放和平移"><span class="toc-number">2.9.</span> <span class="toc-text">缩放和平移</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#管理键盘"><span class="toc-number">2.10.</span> <span class="toc-text">管理键盘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#管理索引"><span class="toc-number">2.11.</span> <span class="toc-text">管理索引</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UIScrollViewDelegate相关基础知识"><span class="toc-number">3.</span> <span class="toc-text">UIScrollViewDelegate相关基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#响应滚动和拖拽"><span class="toc-number">3.1.</span> <span class="toc-text">响应滚动和拖拽</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#管理缩放"><span class="toc-number">3.2.</span> <span class="toc-text">管理缩放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#响应滚动动画"><span class="toc-number">3.3.</span> <span class="toc-text">响应滚动动画</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#响应Inset的改变"><span class="toc-number">3.4.</span> <span class="toc-text">响应Inset的改变</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://res.cloudinary.com/petershi/image/upload/v1530082411/squareShotIcon.png"></div><div class="author-info__name text-center">Uncle Peter</div><div class="author-info__description text-center">Rome was not built in a day</div><div class="follow-button"><a href="https://github.com/chkkassd" target="_blank">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">8</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">3</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="http://blog.derekcoder.com" target="_blank">DerekCoder'sBlog</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://res.cloudinary.com/petershi/image/upload/v1530086666/timg-3.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">Uncle Peter's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">ios中UIScrollView的基础知识</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-01-24</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>本文内容参考了<a href="https://developer.apple.com/documentation/uikit/uiscrollview" target="_blank" rel="noopener">Apple官方文档</a></p><p>无论学什么知识，我觉得最开始最重要的还是学这个东西的概念，然后再是他的用法，最后才是自己的拓展和对其思考。对于iOS知识也一样，所以我们可以通过Apple的官方文档来看看一些概念和用法。很多年以前自己初入iOS编程的时候，也是项目用到什么就学什么，可是现在我总觉得有必要重读一些Apple的文档，把一些基础的概念弄清楚，所以也想把这些记录在此，方便自己以后的温故而知新，也方便其他有需要的同学。以下内容翻译自<a href="https://developer.apple.com/documentation/uikit/uiscrollview" target="_blank" rel="noopener">Apple官方文档</a>，并根据自己的理解做了些必要的补充，方便自己和他人的理解。</p><h1 id="UIScrollView介绍"><a href="#UIScrollView介绍" class="headerlink" title="UIScrollView介绍"></a>UIScrollView介绍</h1><p>总体而言，UIScrollView就是一个可以滚动其包含的子视图，也可以放大缩小其包含的子视图的视图。</p><p>UIScrollView是好几个UIKit类的父类，譬如UITableView，UITextView。</p><p>UIScrollView的主要特性就是他内容的起点会根据他的内容视图随时调整。一般而言，通常都是以应用主窗口的大小来作为UIScrollView的大小（但这不是必须的，我们可随意调整大小）来裁剪他内部的内容视图，以此来显示内容。UIScrollView也会跟踪手指的移动并以此来调整内容视图的起点。内容视图会根据因为手指移动而偏移的新的起点来绘制UIScrollView可见部分的内容。UIScrollView本身并不绘制什么东西，除了展示垂直或水平滚动的指示器。UIScrollView必须知道内容视图的size，因为这样他才能知道什么时候该停止滚动。默认情况下，当滚动超过了内容视图的边界，它会自动反弹回来。</p><p>在UIScrollView里用来管理视图绘制和展示的对象，会将所有子视图铺在一起来保证没有视图会超出屏幕的尺寸。当用户用手指滚动的时候，这个对象会根据需要添加和移除对应的子视图，来保证UIScrollView显示图像的正确性。</p><p>因为UIScrollView不像电脑的图表一样，没有可操作的滚动条，所以他必须要知道一个触摸是否表示要滚动，还是表示跟踪对应的子视图。为了达到这个目的，它启动了一个计时器，并临时截获了touch-down事件，在计时器开始激活之前，会看一下被截获的触摸手指是否会有其他的移动。如果计时器被激活的时候，这个触摸手指没有有效的位置改变，UIScrollView会给被触摸的子视图发送跟踪事件。如果在计时器结束之前，用户手指拖动了足够远的距离，那么UIScrollView会取消任何对子视图的跟踪并且执行滚动操作。子类化UIScrollView，可以重载<a href="https://developer.apple.com/documentation/uikit/uiscrollview/1619418-touchesshouldbegin" target="_blank" rel="noopener"><code>touchesShouldBegin(_:with:in:)</code></a>,<a href="https://developer.apple.com/documentation/uikit/uiscrollview/1619432-ispagingenabled" target="_blank" rel="noopener"><code>isPagingEnabled</code></a>, 和<code>touchesShouldCancel(in:)</code>这几个方法来影响scroll view如何处理滚动手势。</p><p>UIScrollView也可以放大缩小以及平移它里面的内容视图。当用户使用一个pinch-in或者pinch-out手势的时候，scroll view会调整内容视图的偏移和放大缩小的比例。当手势结束的时候，管理内容视图的对象就会根据需要更新包含的子视图。当手势还在进行中的时候，scroll view不会对子视图发送任何跟踪消息。</p><p>UIScrollView类可以拥有一个代理，这个代理必须遵循UIScrollViewDelegate协议。为了使缩放以及平移操作都能顺利进行，代理必须实现<a href="https://developer.apple.com/documentation/uikit/uiscrollviewdelegate/1619426-viewforzooming" target="_blank" rel="noopener"><code>viewForZooming(in:)</code></a>和<code>scrollViewDidEndZooming(_:with:atScale:)</code>这两个方法。 除此之外, 缩放的最大比例和最小比例必须不一样。</p><h1 id="UIScrollView的属性和相关API"><a href="#UIScrollView的属性和相关API" class="headerlink" title="UIScrollView的属性和相关API"></a>UIScrollView的属性和相关API</h1><h2 id="响应scroll-view交互"><a href="#响应scroll-view交互" class="headerlink" title="响应scroll view交互"></a>响应scroll view交互</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> delegate: <span class="type">UIScrollViewDelegate</span>?</span><br></pre></td></tr></table></figure><p>scroll view的代理对象</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">UIScrollViewDelegate</span></span></span><br></pre></td></tr></table></figure><p>遵循了这个协议的对象就是UIScrollView的代理对象，可以通过实现这个协议里方法来自定义很多UIScrollView的操作，譬如滚动，放大缩小，滚动动画等等</p><h2 id="管理内容尺寸和偏移"><a href="#管理内容尺寸和偏移" class="headerlink" title="管理内容尺寸和偏移"></a>管理内容尺寸和偏移</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> contentSize: <span class="type">CGSize</span></span><br></pre></td></tr></table></figure><p>整个scroll view内容视图的尺寸,默认是(0,0)。其实就是scroll view可以滚动范围的大小，如果这个范围不大于scroll view的frame，那么scroll view 就不能滚动，contentSize必须大于scroll view的frame才可以滚动。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> contentOffset: <span class="type">CGPoint</span></span><br></pre></td></tr></table></figure><p>当前内容视图的起点相对于整个scroll view的起点的偏移量，x轴方向的偏移以及y轴方向的偏移。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setContentOffset</span><span class="params">(CGPoint, animated: Bool)</span></span></span><br></pre></td></tr></table></figure><p>通过这个方法可以主动设置contentOffset，并且可以用动画来展示这个转变。譬如你希望在展示scroll view的时候内容视图不在默认的起点，而是希望已经往下滚动了100，那么我们可以用这个函数来设置一个y轴方向的偏移量，并可以用动画展示它。</p><h2 id="管理内容嵌入的行为"><a href="#管理内容嵌入的行为" class="headerlink" title="管理内容嵌入的行为"></a>管理内容嵌入的行为</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> adjustedContentInset: <span class="type">UIEdgeInsets</span>&#123;<span class="keyword">get</span>&#125;</span><br></pre></td></tr></table></figure><p>这是一个只读属性，用来获取被调整后绘制内容视图的区域，可以理解为内容视图距离scroll view四周边界的距离，可以使用<code>contentInsetAdjustmentBehavior</code>这个属性来决定被调整的区域是否包含安全区域的inset。如果包含了，那么安全区域的inset会被自动加入到<code>contentInset</code>这个属性中，并且由<code>adjustedContentInset</code>获得最终的值</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> contentInset: <span class="type">UIEdgeInsets</span></span><br></pre></td></tr></table></figure><p>用户自定义的内容视图和安全区域或者scroll view边界之间的距离。默认的上下左右距离都是0，但是我们可以用它来扩展我们的内容视图和scroll view或者安全区域之间上下左右的间隔。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> contentInsetAdjustmentBehavior: <span class="type">UIScrollView</span>.<span class="type">ContentInsetAdjustmentBehavior</span></span><br></pre></td></tr></table></figure><p>这个属性会指定安全区域的inset会如何被用来影响内容视图的inset，默认值是<code>ContentInsetAdjustmentBehavior.automatic</code>，自动调整scroll view内容视图的insets。它还有其他几个枚举，如下：</p><p><code>scrollableAxes</code>：只在可滚动的方向调整insets</p><p><code>never</code>：从不调整scroll view的insets</p><p><code>always</code>：在内容视图的调整中总是包含安全区域的insets</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adjustedContentinsetDidChange</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>调整后的内容视图的insets如果发生改变，那么这个方法就会被调起。</p><h2 id="获取布局指南"><a href="#获取布局指南" class="headerlink" title="获取布局指南"></a>获取布局指南</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> frameLayoutGuide: <span class="type">UILayoutGuide</span>&#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><p>这是个只读属性，当我们想要明确的使用相对于scroll view本身，而不是相对于他的内容视图的布局约束的时候，我们就要使用这个属性来进行auto layout的约束设置。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> contentLayoutGuide: <span class="type">UILayoutGuide</span>&#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><p>和上面的属性一样，这也是一个只读属性，不过区别在于，当你想要相对于scroll view的内容视图做auto layout约束布局的时候，就要用这个属性来设置。</p><h2 id="对scrollVIew的配置构造"><a href="#对scrollVIew的配置构造" class="headerlink" title="对scrollVIew的配置构造"></a>对scrollVIew的配置构造</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isScrollEnabled: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>这是一个布尔值属性，用来决定scrollView是否可以滚动，默认是true。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isDirectionalLockEnabled: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>这是一个布尔值属性，默认值为false，用来决定用户拖拽的时候，scrollView是否在指定的方向不能滚动，也就是只能在一个方向拖拽。当值为false的时候，在水平和垂直方向都可以滚动；当值为true，并且用户在某一方向（水平或垂直）拖拽的时候，那么scroll view在另一方向就不能滚动了。如果用户拖拽的方向是斜的，那么滚动方向就不会被锁定，用户可以在任何方向拖拽直到拖拽完成。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isPagingEnabled: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>这是一个布尔值属性，用来决定scrollView的滚动是否是按页滚动，默认是false。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scrollsToTop: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>布尔值属性，用来决定滚动到顶部的手势是否可用。Apple自带的用手指点击status bar的手势就是将scroll view自动滚动到顶部。默认值true，自动打开这个手势的。如果设为false，那么scroll view 的代理方法<code>scrollViewShouldScrollToTop(_:)</code>会返回false，或者内容本身已经在顶部了，那就什么都不回发生。</p><p>在滚动到顶部后，代理方法<code>scrollViewDidScrollToTop(_:)</code>就会被调用。</p><p>在Iphone上，如果屏幕上有多于一个的scroll view，那么这个手势就不起作用了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bounces: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>布尔值属性，用来控制当scroll view滚动超过了内容视图的边界的时候，是否会自动弹回。默认值是true，用户可以滚动使scroll view 超出内容视图的边界，但是放手后会自动弹回。如果false，那么当滚动到边界的时候，就会立马停止滚动，无法超出边界，更不会弹回。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> alwaysBounceVertical: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>布尔值属性，用来决定当垂直方向滚动到内容结尾的时候，是否一直可以发生弹回。默认值是false，如果设为true，并且<code>bounces</code>属性也为true，那么垂直方向的拖拽总能发生弹回，即便内容视图的尺寸小于scroll view的边界。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> alwaysBounceHorizontal: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>布尔值属性，用来决定当水平方向滚动到内容结尾的时候，是否一直可以发生弹回。默认值是false，如果设为true，并且<code>bounces</code>属性也为true，那么水平方向的拖拽总能发生弹回，即便内容视图的尺寸小于scroll view的边界。</p><h2 id="获取滚动状态"><a href="#获取滚动状态" class="headerlink" title="获取滚动状态"></a>获取滚动状态</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isTracking: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><p>布尔值只读属性，用来告知用户是否开始触摸内容并准备开始滚动。返回值为true，表明用户已经触摸了内容，但可能还没有开始拖拽，但已经准备开始滚动了。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isDragging: <span class="type">Bool</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><p>布尔值只读属性，用来表明用户是否已经开始拖拽滚动内容。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isDecelerating: <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>布尔值只读属性，用来反馈当用户举起手指的时候，内容视图是否依然在滚动。当用户用手指在scroll view上拖拽了一下，然后手指离开屏幕，然后scroll view依然在减速滚动的时候，那么这个属性就会返回true。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> decelerationRate: <span class="type">UIScrollView</span>.<span class="type">DecelerationRate</span> &#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;</span><br></pre></td></tr></table></figure><p>float类型的值，用来决定当用户滑动离开后，scroll view 减速的速率。在iOS12中，可以用两个常量<code>normal</code>和<code>fast</code>来决定它的速率。</p><h2 id="管理滚动指示器和刷新控制"><a href="#管理滚动指示器和刷新控制" class="headerlink" title="管理滚动指示器和刷新控制"></a>管理滚动指示器和刷新控制</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> indicatorStyle: <span class="type">UIScrollView</span>.<span class="type">IndicatorStyle</span></span><br></pre></td></tr></table></figure><p>滚动指示器的样式，默认是是<code>UIScrollView.IndicatorStyle.default</code>，还有<code>black</code>和<code>white</code>的选项。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scrollIndicatorInsets: <span class="type">UIEdgeInsets</span>&#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure><p>滚动指示器距离scroll view边界的距离，默认都是<code>UIEdgeInsetsZero</code>，就是都是0。这个属性主要用来自定义滚动指示器的位置。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> showsHorizontalScrollIndicator: <span class="type">Bool</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure><p>布尔值属性，用来控制水平方向的滚动指示器是否显示，默认值是true。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> showsVerticalScrollIndicator: <span class="type">Bool</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure><p>布尔值属性，用来控制垂直方向的滚动指示器是否显示，默认值是true。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">flashScrollIndicators</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>当你想要立马显示你的滚动指示器的时候，就调用这个方法，滚动指示器会显示了一下后，然后慢慢消失。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> refreshControl: <span class="type">UIRefreshControl</span>?&#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure><p>从iOS10以后，UIScrollView也拥有了refreshControl。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">scrollRectToVisible</span><span class="params">(CGRect, animated: Bool)</span></span></span><br></pre></td></tr></table></figure><p>滚动到内容视图中的一个指定区域，让它刚刚好可以在屏幕的可见范围内。如果这个指定的区域已经在可见范围内了，那这个方法不会做任何事情。</p><h2 id="管理触摸"><a href="#管理触摸" class="headerlink" title="管理触摸"></a>管理触摸</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">touchesShouldBegin</span><span class="params">(<span class="number">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?, <span class="keyword">in</span> view: UIView)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>当一个手指触摸按下内容视图的时候，如果你想自定义一些默认行为，那么你就需要子类化UIScrollView，并重载这个方法。如果你不希望scroll view把事件消息传递给对应的view，那就返回false，不然就返回true。UIScrollView的默认行为是调用对应subview的UIResponder的事件处理方法来处理。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">touchesShouldCancel</span><span class="params">(<span class="keyword">in</span> view: UIView)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>当scroll view开始对内容视图发送跟踪消息之后，这个方法会被调用。如果返回false，scroll view会停止拖拽并且将触摸事件往前传递给对应的subview。如果返回true，那么就是取消更深层次的消息传递。如果触摸的view不是<code>UIControl</code>对象，那么默认返回值是true，否则默认返回值是false。如果<code>CanCancelContentTouches</code>这个属性是false，那么scroll view 就不会调用这个方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> canCancelContentTouches: <span class="type">Bool</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure><p>布尔值属性，用来控制在内容视图上的触摸是否总是一个消息追踪。</p><p>如果这个值是true并且一个子视图已经开始追踪一个触摸它的手指了，并且这个时候用户拖拽这个手指足够长的距离，这个距离完全可以形成一次滚动，这个view会收到一个<code>touchesCancelled(_:with:)</code>消息，然后scroll view会将这个触摸处理为滚动而不是追踪。如果这个值是false，那么内容视图里的子视图只要开始了追踪，不管手指如何移动，scroll view都不会滚动。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> delaysContentTouches: <span class="type">Bool</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure><p>布尔值属性，用来决定scroll view 是否延迟处理touch-down手势。</p><p>如果这个属性是true，那么scroll view会延迟处理touch-down手势，直到可以确定这个手势的意图就是滚动。如果false，那么scroll view认为这是追踪意图，scroll view 会立即调用<code>touchesShouldBegin(_:with:in:)</code>。默认值是true。</p><h2 id="缩放和平移"><a href="#缩放和平移" class="headerlink" title="缩放和平移"></a>缩放和平移</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> panGestureRecognizer: <span class="type">UIPanGestureRecognizer</span> &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><p>只读属性，平移手势识别器。如果我们需要更精确的平移手势操作，我们就需要用到这个属性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pinchGestureRecognizer: <span class="type">UIPinchGestureRecognizer</span>? &#123; <span class="keyword">get</span> &#125;</span><br></pre></td></tr></table></figure><p>只读属性，捏合手势识别器。如果我们需要更精确的捏合手势操作，我们就需要用到这个属性。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">zoom</span><span class="params">(to rect: CGRect, animated: Bool)</span></span></span><br></pre></td></tr></table></figure><p>缩放内容视图到一个指定大小的区域，好让它在设备上可见。这个方法会将内容视图缩放到指定的rect，并且会根据需要自动调整zoomScale。在实现相应的代理方法后，可通过这个函数来进行缩放。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> zoomScale: <span class="type">CGFloat</span> &#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;</span><br></pre></td></tr></table></figure><p>float类型属性，用来指定当前scroll view的缩放系数。默认值是1.0</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setZoomScale</span><span class="params">(<span class="number">_</span> scale: CGFloat, animated: Bool)</span></span></span><br></pre></td></tr></table></figure><p>设置新的缩放系数，并可以选择用动画来执行这个改变。也是在实现相应的代理方法后，可通过这个函数来进行缩放。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maximumZoomScale: <span class="type">CGFloat</span> &#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;</span><br></pre></td></tr></table></figure><p>用于缩放的最大系数，决定了内容视图可以被放大到多大，如果可以缩放，那么这个值必须比minimum zoom scale大。默认值是1.0</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minimumZoomScale: <span class="type">CGFloat</span> &#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;</span><br></pre></td></tr></table></figure><p>用于缩放的最小系数，决定了内容视图可以被缩小到多小，如果可以缩放。默认值是1.0</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isZoomBouncing: <span class="type">Bool</span>&#123;<span class="keyword">get</span>&#125;</span><br></pre></td></tr></table></figure><p>布尔值只读属性，用来表示缩放已经超出了设定的最大或最小的限制。如果scroll view已经缩放到最大或最小，那么会被弹回到设定的最大和最小系数，这个时候返回true，否则返回false。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bouncesZoom: <span class="type">Bool</span>&#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;</span><br></pre></td></tr></table></figure><p>布尔值属性，用来决定当scroll view缩放超出最大或最小限制后，是否展示弹回的动画。如果是true，那么当缩放超出最大或最小限制后，scroll view 会临时用动画展示超出限制的缩放，如果松开手指，那么会展示退回到限制的最大或最小缩放系数的弹回动画。如果这个值是false，那么当scroll view被缩放到最大或最小限定系数后，会立即停止缩放，也不会有动画。默认值是true。</p><h2 id="管理键盘"><a href="#管理键盘" class="headerlink" title="管理键盘"></a>管理键盘</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keyboardDismissMode: <span class="type">UIScrollView</span>.<span class="type">KeyboardDismissMode</span>&#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;</span><br></pre></td></tr></table></figure><p>当一个拖拽在scroll view 上发生时，键盘消失的方式。这是一个枚举类型。</p><p><code>none</code>：当一个拖拽发生时，键盘不消失</p><p><code>onDrag</code>：当一个拖拽发生时，键盘消失</p><p><code>interactive</code>：交互型，键盘在拖拽触离开屏幕之后，也会消失，但可以再次向上拉，以取消关闭。</p><h2 id="管理索引"><a href="#管理索引" class="headerlink" title="管理索引"></a>管理索引</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> indexDisplayMode: <span class="type">UIScrollView</span>.<span class="type">IndexDisplayMode</span>&#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;</span><br></pre></td></tr></table></figure><p>当用户在滚动的时候，索引显示的方式。这是一个枚举值。</p><p><code>automatic</code>：索引的显示与否会根据适当的情况，自动决定。</p><p><code>alwayshidden</code>:索引不显示</p><h1 id="UIScrollViewDelegate相关基础知识"><a href="#UIScrollViewDelegate相关基础知识" class="headerlink" title="UIScrollViewDelegate相关基础知识"></a>UIScrollViewDelegate相关基础知识</h1><p>UIScrollViewDelegate这个协议所定义的方法允许遵守此协议的对象响应UIScrollView的一些消息，以此来响应并影响一些操作，譬如滚动，缩放，减速滚动内容还有滚动动画等。</p><h2 id="响应滚动和拖拽"><a href="#响应滚动和拖拽" class="headerlink" title="响应滚动和拖拽"></a>响应滚动和拖拽</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidScroll</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span></span><br></pre></td></tr></table></figure><p>当用户在滚动内容视图的时候，如果实现了这个方法，这个方法会被调用来告知代理对象，用户在滚动视图了。比较代表性的用法是，代理对象实现这个方法用来获得content offset的变化，然后绘制内容视图受影响的部分。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewWillBeginDragging</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span></span><br></pre></td></tr></table></figure><p>当scroll view将要开始拖拽滚动的时候，会告诉代理对象。代理对象可能直到拖拽发生了一小段距离才会收到这个消息。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewWillEndDragging</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer&lt;CGPoint&gt;)</span></span></span><br></pre></td></tr></table></figure><p>当用户将要完成拖拽滚动的时候告诉代理对象。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">option <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidEndDragging</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView, willDecelerate decelerate: Bool)</span></span></span><br></pre></td></tr></table></figure><p>当拖拽结束的时候告诉代理对象。这个方法在上面的方法之后被调用，当用户的手指在拖拽后离开屏幕的时候，scroll view会发送这个消息给代理对象。<code>willDecelerate</code>如果是true，说明还在滚动，但是在减速。如果是false，scroll view在手指离开后会立即停止滚动。之前介绍的<code>isDecelerating</code>这个属性能够控制scroll view是否减速。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewShouldScrollToTop</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span> -&gt; <span class="type">Bool</span></span><br></pre></td></tr></table></figure><p>询问代理对象，scroll view是否可以滚到内容顶部。返回true，表明允许，false则不允许。</p><p>如果代理对象没有实现这个方法，那么系统默认是允许的。如果要让点击satus bar返回顶部的手势有效果，<code>scrollsToTop</code>这个属性必须被设置为yes。如果这个方法返回false，那么即便属性<code>scrollsToTop</code>是true，也不会有效果。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidScrollToTop</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span></span><br></pre></td></tr></table></figure><p>当scroll view已经滚动到内容顶部的时候，会立即向代理发送这个消息。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewWillBeginDecelerating</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span></span><br></pre></td></tr></table></figure><p>当scroll view将要开始减速滚动动作的时候，会告诉代理对象。scroll view在用户手指抬起，但scroll view依然在滚动的时候，会调用这个代理方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidEndDecelerating</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span></span><br></pre></td></tr></table></figure><p>当scroll view将滚动动作减速到停止后，会告诉代理对象。</p><h2 id="管理缩放"><a href="#管理缩放" class="headerlink" title="管理缩放"></a>管理缩放</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">viewForZooming</span><span class="params">(<span class="keyword">in</span> scrollView: UIScrollView)</span></span> -&gt; <span class="type">UIView</span>?</span><br></pre></td></tr></table></figure><p>当scroll view发生缩放的时候，scroll view会通过这个方法询问代理对象需要缩放的是哪一个view。如果你不想缩放有效果，可以返回nil。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewWillBeginZooming</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView, with view:UIView?)</span></span></span><br></pre></td></tr></table></figure><p>当在scroll view里内容视图缩放将要开始的时候，会通过这个方法告诉代理对象。这个方法在缩放手势开始的时候，或者通过缩放比例改变而实现动画的时候都会被调用。我们可以用这个方法，在缩放内容之前，来存储一些状态信息或者执行一些额外操作。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidEndZooming</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView, with view: UIView?, atScale scale: CGFloat)</span></span></span><br></pre></td></tr></table></figure><p>当scroll view里的内容视图完成缩放的时候，会通过这个方法告诉代理对象。scroll view在任何弹回动画之后，或者改变缩放比例来实现动画之后，或者任何缩放相关的手势结束之后，都会调用这个方法。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidZoom</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span></span><br></pre></td></tr></table></figure><p>当scroll view的缩放系数改变的时候，也就是正在缩放的时候，会通过这个方法告诉代理对象。</p><h2 id="响应滚动动画"><a href="#响应滚动动画" class="headerlink" title="响应滚动动画"></a>响应滚动动画</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidEndScrollingAnimation</span><span class="params">(<span class="number">_</span> scrollView)</span></span></span><br></pre></td></tr></table></figure><p>当一个滚动动画结束的时候，会通过这个方法告诉代理对象。当用户执行了<code>setContentOffset(_:animated:)</code>或者<code>scrollRectToVisible(_:animated:)</code>方法后，并且他们的动画都是开着的时候，那么等他们的滚动动画结束的时候，就会调用本方法来通知代理对象。</p><h2 id="响应Inset的改变"><a href="#响应Inset的改变" class="headerlink" title="响应Inset的改变"></a>响应Inset的改变</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">scrollViewDidChangeAdjustedContentInset</span><span class="params">(<span class="number">_</span> scrollView: UIScrollView)</span></span></span><br></pre></td></tr></table></figure><p>当scroll view的内嵌数值（inset value）发生改变的时候，会通过这个方法通知代理对象。</p></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Uncle Peter</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2017/01/24/ios中UIScrollView的用法/">http://yoursite.com/2017/01/24/ios中UIScrollView的用法/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a><a class="post-meta__tags" href="/tags/swift/">swift</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2017/06/09/swift中closure捕获列表的研究/"><i class="fa fa-chevron-left"></i><span>swift中closure捕获列表的研究</span></a></div><div class="next-post pull-right"><a href="/2016/08/02/UIScrollView中的Autolayout/"><span>UIScrollView中的Autolayout</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2018 By Uncle Peter</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Welcome to my blog,have a nice day.</div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>