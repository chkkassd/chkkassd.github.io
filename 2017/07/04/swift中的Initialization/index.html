<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="swift中的Initialization"><meta name="keywords" content="swift"><meta name="author" content="Uncle Peter,undefined"><meta name="copyright" content="Uncle Peter"><title>swift中的Initialization | Uncle Peter's Blog</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#struct的Initialization"><span class="toc-number">1.</span> <span class="toc-text">struct的Initialization</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Memberwise-Initializers"><span class="toc-number">1.1.</span> <span class="toc-text">Memberwise Initializers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#值类型的构造器代理"><span class="toc-number">1.2.</span> <span class="toc-text">值类型的构造器代理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#class的Initialization"><span class="toc-number">2.</span> <span class="toc-text">class的Initialization</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Designated-Initializer和Convenience-Initializer"><span class="toc-number">2.1.</span> <span class="toc-text">Designated Initializer和Convenience Initializer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#通过class的继承来看swift的two-phase-process"><span class="toc-number">2.2.</span> <span class="toc-text">通过class的继承来看swift的two-phase process</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#继承和代理规则"><span class="toc-number">2.2.1.</span> <span class="toc-text">继承和代理规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#two-phase-process"><span class="toc-number">2.2.2.</span> <span class="toc-text">two-phase process</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#总结"><span class="toc-number">3.</span> <span class="toc-text">总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://res.cloudinary.com/petershi/image/upload/v1530082411/squareShotIcon.png"></div><div class="author-info__name text-center">Uncle Peter</div><div class="author-info__description text-center">Rome was not built in a day</div><div class="follow-button"><a href="https://github.com/chkkassd" target="_blank">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">5</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">3</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="http://blog.derekcoder.com" target="_blank">DerekCoder'sBlog</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://res.cloudinary.com/petershi/image/upload/v1530086666/timg-3.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">Uncle Peter's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">swift中的Initialization</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-07-04</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/swift/">swift</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>本文相关知识参考了Apple官方的<a href="https://docs.swift.org/swift-book/LanguageGuide/Initialization.html" target="_blank" rel="noopener">Swift文档</a></p><p>Initialization也就是我们说的构造方法，class，struct，enumeration都会通过这个方法来构造一个自己的实例对象，并在这个过程中做一些必要的初始化。但是和Objective-C不一样的是，你会发现swift中的构造方法没有返回值。他们的主要作用就是保证一个类型的实例在被第一次使用前，能够被正确的构造出来，并初始化。class类型的实例还会有析构函数（Deinitialization）。我们还是通过<code>struct</code>和<code>class</code>具体来看一下他们的用法和原理吧。</p><h1 id="struct的Initialization"><a href="#struct的Initialization" class="headerlink" title="struct的Initialization"></a>struct的Initialization</h1><p>无论是struct还是class，他们的实例在被构造的过程中必须要保证所有的<code>stored properties</code>全都被初始化成功，也就是说所有的存储属性必须都有值，否者无法被正确构造。所以基于此，常规构造方法如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">init</span>() &#123;</span><br><span class="line">    name = <span class="string">"Peter"</span></span><br><span class="line">    age = <span class="number">18</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> peopleOne = <span class="type">People</span>()<span class="comment">//name = peter, age = 18</span></span><br></pre></td></tr></table></figure><p>但是同样的，我们也可以为struct的存储属性设置默认值，这样它就能获得一个默认构造方法，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Peter"</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> peopleOne = <span class="type">People</span>()<span class="comment">//name = peter, age = 18</span></span><br></pre></td></tr></table></figure><p>但是很多时候为了更好的适用性，我们通常会自定义我们想要的构造方法，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">init</span>(personName name: <span class="type">String</span>, <span class="number">_</span> age: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> peopleOne = <span class="type">People</span>(personName: <span class="string">"Peter"</span>, <span class="number">18</span>)<span class="comment">//name = peter, age = 18</span></span><br></pre></td></tr></table></figure><p>上面构造方法中的<code>personName</code>叫做<code>Argument Label</code>是在构造方法被外部调用时使用的，而它后面的<code>name</code>叫做<code>Parameter Name</code>是在构造方法内部使用的，如果希望外部调用的时候简洁一些，不要<code>Argument Label</code>那就可以直接用<code>__</code>下划线替代。</p><h2 id="Memberwise-Initializers"><a href="#Memberwise-Initializers" class="headerlink" title="Memberwise Initializers"></a>Memberwise Initializers</h2><p>struct还有一个很特别的默认提供的构造方法，<code>Memberwise Initializers</code>，我们可以把它叫做逐一成员构造法，按照字面意思即可理解，就是将他的所有成员逐个全部赋值，只要struct没有自定义的构造方法，那么就会默认获得这个构造方法。用法如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">""</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> peopleOne = <span class="type">People</span>(ame: <span class="string">"Peter"</span>, age: <span class="number">18</span>)<span class="comment">//name = peter, age = 18</span></span><br></pre></td></tr></table></figure><h2 id="值类型的构造器代理"><a href="#值类型的构造器代理" class="headerlink" title="值类型的构造器代理"></a>值类型的构造器代理</h2><p>什么是构造器代理(Initializer Delegation)，值类型的构造器代理其实就是类型里面有不止一个构造方法，其中一个构造方法的实现里调用了本类型里的另一个构造方法，来避免一些重复的代码。class类型因为有继承的关系，构造器代理会复杂很多，我们下面会讲。直接看代码就明白了，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">  <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">  <span class="keyword">init</span>(personName name: <span class="type">String</span>, <span class="number">_</span> age: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span>(info: (<span class="type">String</span>, <span class="type">Int</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> infoName = info.<span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> infoAge = info.<span class="number">1</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(personName: infoName, infoAge)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> peopleOne = <span class="type">People</span>(info: (<span class="string">"Peter"</span>, <span class="number">18</span>))<span class="comment">//name = peter, age = 18</span></span><br></pre></td></tr></table></figure><p>上面的代码，我们定义了另外一个构造器，入参是一个<code>(String, Int)</code>类型的<code>Tuple</code>，但是我们在它的实现里，通过代理给原有的构造方法来实现了完整构造，并节省了重复代码。</p><p><img src="https://i.loli.net/2018/07/05/5b3d85e43385a.jpg" alt="开心"></p><h1 id="class的Initialization"><a href="#class的Initialization" class="headerlink" title="class的Initialization"></a>class的Initialization</h1><p>类类型中的构造方法比起值类型来说，要复杂一些，因为它可以继承等，我们还是通过例子从最简单的开始说起，同样的，如果类里面给所有的存储属性提供了默认值，那么它可以获得一个默认的构造方法<code>init()</code>，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Peter"</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> personOne = <span class="type">Person</span>()<span class="comment">//name = Peter, age = 18</span></span><br></pre></td></tr></table></figure><h2 id="Designated-Initializer和Convenience-Initializer"><a href="#Designated-Initializer和Convenience-Initializer" class="headerlink" title="Designated Initializer和Convenience Initializer"></a>Designated Initializer和Convenience Initializer</h2><p>Designated Initializer我们直译为指定构造器，这是class类型里面的主要构造器，我们平时写的构造器基本都是Designated Initializer，来看例子，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Peter"</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这就是Designated Initializer</span></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> personOne = <span class="type">Person</span>(name: <span class="string">"Peter"</span>, age: <span class="number">18</span>)<span class="comment">//name = Peter, age = 18</span></span><br></pre></td></tr></table></figure><p>同时，类类型里面还有Convenience Initializer，我们直译为便利构造器，它只能横向代理，也就是说在它的实现里，最后必须调用本类里其他的指定构造器。便利构造器很多时候是为了一些特殊的场景，为了方便初始化而创造出来的，他的实现是基于某个指定构造器的，所以最终必须要调用某个指定构造器。我们看例子，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Peter"</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这就是Designated Initializer</span></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这就是Convenience Initializer</span></span><br><span class="line">  <span class="keyword">convenience</span> <span class="keyword">init</span>(info: (<span class="type">String</span>, <span class="type">Int</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> infoName = info.<span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> infoAge = info.<span class="number">1</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(name: infoName, age: infoAge)<span class="comment">//调用指定构造器</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> personOne = <span class="type">Person</span>(info: (<span class="string">"Peter"</span>, <span class="number">18</span>))<span class="comment">//name = Peter, age = 18</span></span><br></pre></td></tr></table></figure><h2 id="通过class的继承来看swift的two-phase-process"><a href="#通过class的继承来看swift的two-phase-process" class="headerlink" title="通过class的继承来看swift的two-phase process"></a>通过class的继承来看swift的two-phase process</h2><h3 id="继承和代理规则"><a href="#继承和代理规则" class="headerlink" title="继承和代理规则"></a>继承和代理规则</h3><p>上面我们看到了class类型的指定构造器和便利构造器，还是比较简单的，但是如果刚刚的<code>Person</code>的类型又派生出多个子类，有了继承，那就变得稍稍复杂了。我们还是来看一下吧，我们看例子：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">"Peter"</span></span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这就是Designated Initializer</span></span><br><span class="line">  <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.name = name</span><br><span class="line">    <span class="keyword">self</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//这就是Convenience Initializer</span></span><br><span class="line">  <span class="keyword">convenience</span> <span class="keyword">init</span>(info: (<span class="type">String</span>, <span class="type">Int</span>)) &#123;</span><br><span class="line">    <span class="keyword">var</span> infoName = info.<span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> infoAge = info.<span class="number">1</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(name: infoName, age: infoAge)<span class="comment">//调用指定构造器</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> studentNumber: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Student</code>继承自<code>Person</code>，<code>因为没有实现任何指定构造方法，所以自动继承父类Person的指定构造方法</code>，这是swift中继承规则的第一条，第二条是，<code>如果派生类实现了父类的所有指定构造方法，无论是规则一继承实现还是重载实现，那么可以继承父类的所有便利构造方法</code>。上面的例子中，<code>Student</code>满足了这两个条件，所以它继承了父类所有的指定和便利构造方法。我们来试试，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> studentOne = <span class="type">Student</span>(name: <span class="string">"Peter"</span>, age: <span class="number">18</span>)<span class="comment">//Student可以调用父类的指定构造器</span></span><br><span class="line"><span class="keyword">let</span> studentTwo = <span class="type">Student</span>(info: (<span class="string">"Jack"</span>, <span class="number">20</span>))<span class="comment">//Student可以调用父类的便利构造器</span></span><br></pre></td></tr></table></figure><p>当然，我们也可以不继承父类的指定构造器，我们可以直接重载它，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> studentNumber: <span class="type">Int</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//重载父类指定构造器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.studentNumber = <span class="number">0</span></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, age: age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，上面的初始化<code>studentOne</code>和<code>studentTwo</code>依然是可行的，它符合swift的两条继承规则。但是重载父类指定构造器必须调用父类的指定构造器，也就是上述代码中的<code>super.init(name: name, age: age)</code>，这个也就是我们所说的纵向代理。指定构造器只能纵向代理。</p><p>同时我们也可以重载父类的便利构造方法，但是不用写<code>override</code>关键字，原因是便利构造器只能横向代理，也就是只能代理给本类的指定构造器，实际上并没有调用父类的同名便利构造方法，严格意义上来讲，重载父类便利构造方法不能算作重载，所以也就不用<code>override</code>关键字了。来看代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> studentNumber: <span class="type">Int</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//重载父类指定构造器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.studentNumber = <span class="number">0</span></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, age: age)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//‘重载’父类便利构造器，严格意义上不能称之为重载</span></span><br><span class="line">    <span class="keyword">convenience</span> <span class="keyword">init</span>(info: (<span class="type">String</span>, <span class="type">Int</span>)) &#123;</span><br><span class="line">        <span class="keyword">let</span> infoName = info.<span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> infoAge = info.<span class="number">1</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="keyword">init</span>(name: infoName, age: infoAge)</span><br><span class="line">        <span class="keyword">self</span>.studentNumber = <span class="number">8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok，让我们少许总结一下吧</p><blockquote><p>class中的继承规则</p></blockquote><p>1.如果子类没有实现任何指定构造方法，那么该子类会自动继承父类的所有指定构造方法。</p><p>2.如果子类实现了父类的所有指定构造方法，无论是通过规则一继承的，还是通过重载实现的，那么子类可以继承父类的所有便利构造方法。</p><blockquote><p>class的构造方法的代理规则（我们可以简称为：指定构造器必须纵向代理，便利构造器必须横向代理）</p></blockquote><p>1.一个指定构造方法必须调用它直接父类的构造方法。</p><p>2.一个便利构造方法必须调用本类的其他构造方法。</p><p>3.一个便利构造方法无论调用本类多少构造方法，最终必须调用一个指定构造方法。</p><p>我们来看一张图，就十分清晰明了了，<code>指定构造器必须纵向代理，便利构造器必须横向代理</code>如下：</p><p><img src="https://res.cloudinary.com/petershi/image/upload/v1530774621/initializerDelegation02_2x.png" alt="代理规则"></p><h3 id="two-phase-process"><a href="#two-phase-process" class="headerlink" title="two-phase process"></a>two-phase process</h3><p>two-phase process，我直译为两段式构造过程。那什么叫两段式构造过程，其实就是swift把创建一个实例类的过程分成了两步。</p><blockquote><p>第一步</p></blockquote><ul><li><p>class中的一个指定构造器或便利构造器被调用</p></li><li><p>这个实例的内存被分配，但是该内存还没有被初始化</p></li><li><p>class中的指定构造器给class中的所有存储属性赋值，并且这些存储属性的内存被初始化</p></li><li><p>本类中的指定构造器调用父类的指定构造器，让父类完成和本类一样的工作初始化所有存储属性</p></li><li><p>顺着继承链一直到达最顶层的父类，完成同样的操作</p></li><li><p>当所有父类均对自有的存储属性完成初始化操作，保证了所有存储属性有值，那么该实例被完全初始化，第一步也就完成了</p></li></ul><blockquote><p>第二步</p></blockquote><ul><li><p>从继承链的最顶层逐步往下，没个指定构造器都有机会进一步定制实例对象，现在没个构造器里可是使用<code>self</code>来修改属性或者调用实例方法等</p></li><li><p>最终，在这条链中的便利构造器有机会去进一步自定义实例对象，并且可以使用<code>self</code>关键字</p></li></ul><p>所以还记得我们上面举过的一个例子吗，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> studentNumber: <span class="type">Int</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//重载父类指定构造器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.studentNumber = <span class="number">0</span></span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, age: age)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们把上述代码指定构造器里的<code>self.studentNumber = 0</code>和<code>super.init(name: name, age: age)</code>这两行对调可以吗？我们试一下，代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>: <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> studentNumber: <span class="type">Int</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//重载父类指定构造器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, age: age)<span class="comment">//Property 'self.studentNumber' not initialized at super.init call</span></span><br><span class="line">      	<span class="keyword">self</span>.studentNumber = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会立马报错<code>Property &#39;self.studentNumber&#39; not initialized at super.init call</code>，为什么，因为在两段式构造过程中，第一步要求派生类必须自下而上的完成存储属性的初始化，所以上述代码必须先将本类的<code>studentNumber</code>先初始化，然后调用父类指定构造器，让父类做相同工作。</p><p>同样的，便利构造器也必须在最终调用完指定构造器后，才能使用<code>self</code>来自定义实例对象，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">convenience</span> <span class="keyword">init</span>(info: (<span class="type">String</span>, <span class="type">Int</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> infoName = info.<span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> infoAge = info.<span class="number">1</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="keyword">init</span>(name: infoName, age: infoAge)<span class="comment">//必须先调用完指定构造器</span></span><br><span class="line">    <span class="keyword">self</span>.studentNumber = <span class="number">8</span><span class="comment">//然后才能自己自定义实例对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>struct和class的init构造方法是我们很常用的方法，不过里面也有非常多的细节和注意的地方，希望上述相关知识在你以后使用构造方法的时候能够帮上你的忙。</p></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Uncle Peter</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2017/07/04/swift中的Initialization/">http://yoursite.com/2017/07/04/swift中的Initialization/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/swift/">swift</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/02/26/swift中map与flatMap的用法与研究/"><i class="fa fa-chevron-left"></i><span>swift中map与flatMap的用法与研究</span></a></div><div class="next-post pull-right"><a href="/2017/06/09/swift中closure捕获列表的研究/"><span>swift中closure捕获列表的研究</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2018 By Uncle Peter</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Welcome to my blog,have a nice day.</div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>