<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="description" content="UIStackView基础知识"><meta name="keywords" content="iOS,swift"><meta name="author" content="Uncle Peter,undefined"><meta name="copyright" content="Uncle Peter"><title>UIStackView基础知识 | Uncle Peter's Blog</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,copy:{success:"Copy successfully",error:"Copy error",noSupport:"The browser does not support"}}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="Toggle article">Toggle site</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#UIStackView简介"><span class="toc-number">1.</span> <span class="toc-text">UIStackView简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UIStackView和Auto-Layout的关系"><span class="toc-number">2.</span> <span class="toc-text">UIStackView和Auto Layout的关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#定位和调整stack-view的大小"><span class="toc-number">3.</span> <span class="toc-text">定位和调整stack view的大小</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#stack-view的一些通用用法"><span class="toc-number">4.</span> <span class="toc-text">stack view的一些通用用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#只确定stack-view的位置"><span class="toc-number">4.1.</span> <span class="toc-text">只确定stack view的位置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在stack-view轴线方向确定尺寸"><span class="toc-number">4.2.</span> <span class="toc-text">在stack view轴线方向确定尺寸</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#在垂直于stack-view轴线方向确定尺寸"><span class="toc-number">4.3.</span> <span class="toc-text">在垂直于stack view轴线方向确定尺寸</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#确定stack-view的位置和尺寸"><span class="toc-number">4.4.</span> <span class="toc-text">确定stack view的位置和尺寸</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#管理UIStackView的布局和展示"><span class="toc-number">5.</span> <span class="toc-text">管理UIStackView的布局和展示</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#stack-view的subviews和arrangedSubviews的关系"><span class="toc-number">6.</span> <span class="toc-text">stack view的subviews和arrangedSubviews的关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#动态的改变stack-view的内容"><span class="toc-number">7.</span> <span class="toc-text">动态的改变stack view的内容</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UIStackView相关属性和API"><span class="toc-number">8.</span> <span class="toc-text">UIStackView相关属性和API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#管理布局视图"><span class="toc-number">8.1.</span> <span class="toc-text">管理布局视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设置布局属性"><span class="toc-number">8.2.</span> <span class="toc-text">设置布局属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#设置被管理视图之间的间距"><span class="toc-number">8.3.</span> <span class="toc-text">设置被管理视图之间的间距</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://res.cloudinary.com/petershi/image/upload/v1530082411/squareShotIcon.png"></div><div class="author-info__name text-center">Uncle Peter</div><div class="author-info__description text-center">Rome was not built in a day</div><div class="follow-button"><a href="https://github.com/chkkassd" target="_blank">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">Articles</span><span class="pull-right">8</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">Tags</span><span class="pull-right">3</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">Categories</span><span class="pull-right">2</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="http://blog.derekcoder.com" target="_blank">DerekCoder'sBlog</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image:url(https://res.cloudinary.com/petershi/image/upload/v1530086666/timg-3.jpg)"><div id="page-header"><span class="pull-left"><a id="site-name" href="/">Uncle Peter's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">UIStackView基础知识</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-08-09</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/iOS/">iOS</a></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>本文参考<a href="https://developer.apple.com/documentation/uikit/uistackview" target="_blank" rel="noopener">Apple官方文档</a></p><p>UIStackView是在iOS9的时候发布的一个新特性，用来将一些视图按照纵向或者横向，以流线形式布局。可以帮助开发者更好更方便的布局，很多场景都用得到。</p><h1 id="UIStackView简介"><a href="#UIStackView简介" class="headerlink" title="UIStackView简介"></a>UIStackView简介</h1><p>stack view可以让用户借助Auto Layout的帮助，来创建出可以动态适应设备方向，屏幕不同尺寸和空间变化的视图布局。stack view有一个属性<code>arrangedSubviews</code>，包含着需要被stack view管理布局的所有视图，这个属性里包含的所有views都会根据在这个数组的顺序，依次沿着stack view的轴线分布。stack view精确的布局主要还是取决于它的几个关键布局属性，<a href="https://developer.apple.com/documentation/uikit/uistackview/1616223-axis" target="_blank" rel="noopener"><code>axis</code></a>,<a href="https://developer.apple.com/documentation/uikit/uistackview/1616233-distribution" target="_blank" rel="noopener"><code>distribution</code></a>,<a href="https://developer.apple.com/documentation/uikit/uistackview/1616243-alignment" target="_blank" rel="noopener"><code>alignment</code></a>，<code>spacing</code>还有其他的一些属性。这几个属性什么概念呢，可以看一下下图，有个大概的了解，下图是一个轴线为水平方向的stack view：</p><p><img src="https://res.cloudinary.com/petershi/image/upload/v1533800250/stackView1.png" alt="水平方向的stack view"></p><p>其实，<code>Alignment</code>就是垂直于轴线方向的对齐方式；</p><p><code>Distribution</code>就是轴线方向的分布方式；</p><p><code>Spacing</code>就是视图之间的间距；</p><p>在storyboard里使用stack view是非常简单的。我们只从组件库内拖拽一个UIStackView到storyboard里，然后固定好位置，然后往stack view里拖入我们想要的视图组件即可。stack view会基于内部的view，以及我们设置的布局属性来调整对应的布局。</p><blockquote><p>我们需要指定stack view的起点（position），但是stack view的尺寸，也就是长宽是不一定要固定的，stack可以根据内容自动调整它的尺寸，当然我们也可以直接固定它的长宽。</p></blockquote><h1 id="UIStackView和Auto-Layout的关系"><a href="#UIStackView和Auto-Layout的关系" class="headerlink" title="UIStackView和Auto Layout的关系"></a>UIStackView和Auto Layout的关系</h1><p>在使用stack view的时候，虽然我们可以不用手动去添加auto layout，但是实际上，stack view本身已经使用了Auto Layout来布局被它管理的视图。譬如说，在水平方向的stack view里，它所管理的第一个视图的左边会紧靠着stack view的左边，stack view里的最后一个视图的右边会紧靠着stack view的右边。相对应的，在垂直方向的stack view里，第一个和最后一个视图会相对应的紧靠着stack view的上边和下边。如果我们设置了<code>isLayoutMarginsRelativeArrangement</code>这个属性为true，那么前面的例子第一个视图和最后一个视图会紧靠的是相对应的margin，而不是edge了。其实stack view能够做出上述的布局，本质上就是利用了Auto Layout，只是它帮我们默认添加好了而已。</p><p>同理，当我门设置stack view的一些布局属性的时候，其实底层也是再操作一些Auto Layout，只是无需我们自己添加，而是现在变得更加简单，我们只需要更改stack view对应的布局属性即可。</p><p>对于所有沿着轴线方向的布局来说，除了<code>UIStackView.Distribution.fillEqually</code>这种布局之外，stack view都会用每一个被管理的view的<code>intrinsicContentSize</code>属性来计算轴线方向的尺寸。但是<code>UIStackView.Distribution.fillEqually</code>这种布局的时候，stack view会重新计算轴线方向的尺寸，好让每一个被管理的view尺寸相同，stack view会尽可能的拉升所有被管理的views，好让他们在沿着轴线方向上的尺寸和拥有最大intrinsic size的view相等。</p><p>对于所有垂直于轴线方向的对齐方式来说，除了<code>UIStackView.Alignment.fill</code>这种对齐方式之外，stack view都会用每一个被管理的view的<code>intrinsicContentSize</code>属性来计算垂直于轴线方向的尺寸。但是<code>UIStackView.Alignment.fill</code>这种对齐方式，stack view会重新计算垂直于轴线方向的尺寸，好让每一个被管理的view填满stack view，stack view会尽可能的拉升所有被管理的views，好让他们在垂直于轴线方向上的尺寸和拥有最大intrinsic size的view相等。</p><h1 id="定位和调整stack-view的大小"><a href="#定位和调整stack-view的大小" class="headerlink" title="定位和调整stack view的大小"></a>定位和调整stack view的大小</h1><p>虽然stack view可以不直接使用auto layout来布局它里面的内容，但是stack view本身还是需要auto layout来布局的。通常情况下，需要至少要钉住两条相近的边才能确定stack view的起点。stack view的具体尺寸，也就是它的长宽可以通过里面的内容，四通自动计算出来。</p><ul><li><p>在stack view的轴线方向，stack view的尺寸 = 所有被管理的view轴线方向的尺寸之和 + 轴线方向的所有间距之和</p></li><li><p>在stack view垂直于轴线的防线，stack view的尺寸 = 所有被管理的view当中垂直于轴线方向的最大尺寸</p></li><li><p>如果设置了<code>isLayoutMarginsRelativeArrangement</code>这个属性为true，那么stack view的尺寸就要算上margin边距</p></li></ul><p>我们也可以对stack view再添加一些额外的约束，譬如指定宽，高等等，stack view都会根据这些来调整布局和尺寸之类。</p><h1 id="stack-view的一些通用用法"><a href="#stack-view的一些通用用法" class="headerlink" title="stack view的一些通用用法"></a>stack view的一些通用用法</h1><h2 id="只确定stack-view的位置"><a href="#只确定stack-view的位置" class="headerlink" title="只确定stack view的位置"></a>只确定stack view的位置</h2><p>我们可以通过锁定stack view两条相邻的边到其父视图的距离，来确定stack view的位置。在这种情况下，stack view的尺寸会随着被管理的视图，在两个方向上伸缩。当你想要stack view的内容都接近它的intrinsic content size，并且你想要根据这个stack view来管理其他界面元素的布局，那么这个方法很有用。</p><p><img src="https://res.cloudinary.com/petershi/image/upload/v1533882929/stackView2.png" alt="只固定stack view的位置"></p><h2 id="在stack-view轴线方向确定尺寸"><a href="#在stack-view轴线方向确定尺寸" class="headerlink" title="在stack view轴线方向确定尺寸"></a>在stack view轴线方向确定尺寸</h2><p>在这种情况下，除了确定stack view的位置以外，还会对stack view添加一个约束，用以确定stack view在轴线方向上的尺寸。那么在轴线方向上，stack view会根据你设置的布局属性，来填满stack view；在垂直于轴线的方向上，stack view会自由伸缩，垂直于轴线方向的尺寸=所有被管理的视图中，垂直于轴线方向上，尺寸最大的那一个。</p><p><img src="https://res.cloudinary.com/petershi/image/upload/v1533883328/stackView3.png" alt="在stack view轴线方向确定尺寸"></p><h2 id="在垂直于stack-view轴线方向确定尺寸"><a href="#在垂直于stack-view轴线方向确定尺寸" class="headerlink" title="在垂直于stack view轴线方向确定尺寸"></a>在垂直于stack view轴线方向确定尺寸</h2><p>这种情况和上面的差不多，但是它是固定了位置和垂直于轴线方向的尺寸。那么stack view在轴线方向上的尺寸，会随着你添加或者删除，自动伸缩。除非你使用fillEqually，不然的话被管理的视图都会根据它实际的尺寸进行布局。垂直于轴线方向上的对齐方式取决于alignment属性。</p><p><img src="https://res.cloudinary.com/petershi/image/upload/v1533891204/stackView4.png" alt="在垂直于stack view轴线方向确定尺寸"></p><h2 id="确定stack-view的位置和尺寸"><a href="#确定stack-view的位置和尺寸" class="headerlink" title="确定stack view的位置和尺寸"></a>确定stack view的位置和尺寸</h2><p>在这种情况下，我们已经为stack view添加了约束，固定了它的位置和尺寸，那么stack view只能在固定大小的空间里，根据设置好的布局属性来布局。</p><p><img src="https://res.cloudinary.com/petershi/image/upload/v1533891436/stackView5.png" alt="确定stack view的位置和尺寸"></p><h1 id="管理UIStackView的布局和展示"><a href="#管理UIStackView的布局和展示" class="headerlink" title="管理UIStackView的布局和展示"></a>管理UIStackView的布局和展示</h1><p>其实UIStackView是一个没有被渲染的UIView的子类。它不是可视化的，肉眼看不见，不提供视觉界面，但是它可以管理在它里面视图的布局，位置，尺寸等。因此，一些UIView的属性，譬如backgroundColor，在stack view上是不起作用的。同样的，我们也无法重载stack view的layerClass，draw(_:)，draw(__:in)这些方法。</p><p>以下属性会影响stack view如何布局它里面的内容视图：</p><ul><li><p><code>axis</code>：决定了stack view的方向，要么是垂直方向，要么是水平方向</p></li><li><p><code>distribution</code>：决定了沿着stack view的轴线方向的分布</p></li><li><p><code>alignment</code>：决定了垂直于轴线方向的布局</p></li><li><p><code>spacing</code>：决定了被管理视图之间的最小间距</p></li><li><p><code>isBacelineRelativeArrangement</code>：决定视图之间的垂直间距是否从底线开始算起</p></li><li><p><code>isLayoutMarginsRelativeArrangement</code>：决定了stack view是否根据margins来布局其中的内容</p></li></ul><p>通常来说，我们用一个stack view来布局少量的视图元素。但是我们可以通过stack view内嵌一个stack view来创建更多复杂的视图层级。</p><p>同样的，我们也可以为stack view内部被管理的view再添加一些约束，用来做一些额外的布局，但要避免产生冲突。</p><h1 id="stack-view的subviews和arrangedSubviews的关系"><a href="#stack-view的subviews和arrangedSubviews的关系" class="headerlink" title="stack view的subviews和arrangedSubviews的关系"></a>stack view的subviews和arrangedSubviews的关系</h1><p>stack view有一个<code>arrangedSubviews</code>属性，里面是全部被stack view管理布局的视图，它是<code>subviews</code>的子集。严格来讲，stack view会保证以下几条规则：</p><ul><li><p>当stack view添加一个view到它的<code>arrangedSubviews</code>，如果这个view之前并不存在，那它必定也会被添加到<code>subviews</code>。</p></li><li><p>当一个subview从stack view里移除了，那么stack view也一定会把这个view从<code>arrangedSubviews</code>里移除。</p></li><li><p>把一个view从stack view的<code>arrangedSubviews</code>这个数组里移除，并不会把它从<code>subviews</code>里移除。只是stack view不再管理这个view的位置和布局，但是这个view依然在stack view里，作为一个子视图，如果可见的话，也会被渲染。</p></li></ul><p>虽然<code>arrangedSubviews</code>属性包含的视图是<code>subviews</code>的子集，但是这些数组里顺序确实相互独立的。</p><ul><li><p><code>arrangedSubviews</code>里的顺序决定了stack view里视图显示的顺序。随着index从小到大，垂直方向是从上到下，水平方向是从左到右。</p></li><li><p><code>subviews</code>里的顺序决定了视图层次在z轴上的顺序。index越大的view就约在上面。</p></li></ul><h1 id="动态的改变stack-view的内容"><a href="#动态的改变stack-view的内容" class="headerlink" title="动态的改变stack view的内容"></a>动态的改变stack view的内容</h1><p>当对stack view的<code>arrangedSubviews</code>这个数组添加，移除或插入view的时候，或者其中的一个view<code>isHidden</code>属性改变的时候，stack view都会自动更新它的布局。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Appears to remove the first arranged view from the stack.</span></span><br><span class="line"><span class="comment">// The view is still inside the stack, it's just no longer visible, and no longer contributes to the layout.</span></span><br><span class="line"><span class="keyword">let</span> firstView = stackView.arrangedSubviews[<span class="number">0</span>]</span><br><span class="line">firstView.isHidden = <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>我们也可以将这个属性的变化用动画演示，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Animates removing the first item in the stack.</span></span><br><span class="line"><span class="type">UIView</span>.animateWithDuration(<span class="number">0.25</span>) &#123; () -&gt; <span class="type">Void</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">let</span> firstView = stackView.arrangedSubviews[<span class="number">0</span>]</span><br><span class="line">    firstView.isHidden = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以为不同的size class指定不同的布局，那么随着不同设备的size class的切换，系统会自动用动画演示这些转变。</p><h1 id="UIStackView相关属性和API"><a href="#UIStackView相关属性和API" class="headerlink" title="UIStackView相关属性和API"></a>UIStackView相关属性和API</h1><h2 id="管理布局视图"><a href="#管理布局视图" class="headerlink" title="管理布局视图"></a>管理布局视图</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">addArrangedSubview</span><span class="params">(<span class="number">_</span> view: UIView)</span></span></span><br></pre></td></tr></table></figure><p>将指定的view添加进到<code>arrangedSubviews</code>这个数组的末尾。如果这个view不存在stack view里，那么也会添加进<code>subviews</code>内，如果这个view已经存在stack view里了，那么就不会通知<code>subviews</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrangedSubviews: [<span class="type">UIView</span>] &#123;<span class="keyword">get</span>&#125;</span><br></pre></td></tr></table></figure><p>一个UIView类型的数组，包含了所有被stack view 管理布局的view，是<code>subviews</code>的一个子集。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">insertArrangedSubview</span><span class="params">(<span class="number">_</span> view: UIView, at stackIndex:Int)</span></span></span><br></pre></td></tr></table></figure><p>将指定的view添加进到<code>arrangedSubviews</code>这个数组指定的index。如果这个view不存在stack view里，那么也会添加进<code>subviews</code>内，如果这个view已经存在stack view里了，那么就不会通知<code>subviews</code>。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeArrangedSubview</span><span class="params">(<span class="number">_</span> view: UIView)</span></span></span><br></pre></td></tr></table></figure><p>从<code>arrangedSubviews</code>这个数组里移除指定的view，但是并没有从<code>subviews</code>里移除这个view。也就是说，stack view只是不再管理这个view的位置，布局等，但是依然存在在subview的视图层次内。</p><p>如果我们希望从<code>arrangedSubviews</code>里删除这个view后，不再看到这个view，那么我们要执行<code>removeFromSuperview()</code>这个方法，或者我们需要把这个view的<code>isHidden</code>属性设为true。</p><h2 id="设置布局属性"><a href="#设置布局属性" class="headerlink" title="设置布局属性"></a>设置布局属性</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> alignment: <span class="type">UIStackView</span>.<span class="type">Alignment</span> &#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;</span><br></pre></td></tr></table></figure><p>决定了垂直于轴线方向的布局。默认值是<code>UIStackView.Alignment.fill</code>。这是个枚举值，如下：</p><ul><li><p><code>fill</code>：让视图在垂直于轴线的方向尽可能填满可以被填充的空间</p></li><li><p><code>leading</code>：只有stack view在垂直方向时有用，就是左对齐</p></li><li><p><code>top</code>：只有stack view在水平方向时有用，就是上对齐</p></li><li><p><code>firstBaseLine</code>：stack view根据第一个基线来对齐它的视图，只在stack view水平方向时有用</p></li><li><p><code>center</code>：居中对齐</p></li><li><p><code>trailing</code>：只有stack view在垂直方向时有用，就是右对齐</p></li><li><p><code>bottom</code>：只有stack view在水平方向时有用，就是下对齐</p></li><li><p><code>lastBaseLine</code>：stack view根据第最后一个基线来对齐它的视图，只在stack view水平方向时有用</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> axis: <span class="type">NSLayoutConstraint</span>.<span class="type">Axis</span>&#123;<span class="keyword">get</span> <span class="keyword">set</span>&#125;</span><br></pre></td></tr></table></figure><p>这个属性决定了stack view内部被管理视图的排列方向。默认值是<code>NSLayoutConstraint.Axis.horizontal</code>，也就是水平方向。这是个枚举值，如下：</p><ul><li><p><code>horizontal</code>：表示水平方向</p></li><li><p><code>vertical</code>：表示垂直方向</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isBaselineRelativeArrangement: <span class="type">Bool</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure><p>布尔值属性，用来决定被管理视图之间的垂直间距是否要根据基线来测算。默认值是false。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> distribution: <span class="type">UIStackView</span>.<span class="type">Distribution</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure><p>决定了沿着stack view的轴线方向的视图分布。默认值是<code>UIStackView.Distribution.fill</code>，这是个枚举值，如下：</p><ul><li><p><code>fill</code>：stack view重新计算被管理视图的尺寸，让视图在轴线方向尽可能填满可以被填充的空间。当被管理的视图无法正好适配stack view的时候，它根据视图的抗压缩优先级收缩视图，当被管理的视图无法填满stack view的时候，它会根据hugging优先级来缩放视图。</p></li><li><p><code>fillEqually</code>：stack view重新计算被管理视图的尺寸，让视图在轴线方向尽可能填满可以被填充的空间。被管理的视图在沿轴线方向的尺寸相同。</p></li><li><p><code>fillProportionally</code>:stack view重新计算被管理视图的尺寸，让视图在轴线方向尽可能填满可以被填充的空间。被管理的视图根据它们沿轴线方向的固有尺寸，按照比例合理的安排它们的尺寸</p></li><li><p><code>equalSpacing</code>：stack view指定被管理视图的位置，让视图在轴线方向尽可能填满可以被填充的空间。当被管理的视图无法填满stack view的时候，它会在视图之间均匀的填充间距；当被管理的视图无法正好适配stack view的时候，它根据视图的抗压缩优先级收缩视图</p></li><li><p><code>equalCentering</code>：stack view会尝试指定被管理视图的位置，好让视图在轴线方向，每个视图中心点到中心点的距离相等，并且如果你设置了<code>spacing</code>属性，这个值也会被包含在内。当被管理的视图无法正好适配stack view的时候，它会拉伸视图之间的间距，直到这个间距达到<code>spacing</code>属性设置的最小值。如果这个时候被管理的视图还是无法正好适配stack view的时候，它根据视图的抗压缩优先级收缩视图。</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isLayoutMarginsRelativeArrangement: <span class="type">Bool</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure><p>布尔值属性，用来决定stack view是否根据layout margins来布局被管理的视图。默认值是false</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> spacing: <span class="type">CGFloat</span> &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br></pre></td></tr></table></figure><p>stack view里两个相邻的被管理视图之间的最小间距。默认值是0.0</p><h2 id="设置被管理视图之间的间距"><a href="#设置被管理视图之间的间距" class="headerlink" title="设置被管理视图之间的间距"></a>设置被管理视图之间的间距</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">customSpacing</span><span class="params">(after arrangedSubview: UIView)</span></span> -&gt; <span class="type">CGFloat</span></span><br></pre></td></tr></table></figure><p>返回指定视图后面的自定义间距</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setCustomSpacing</span><span class="params">(<span class="number">_</span> spacing: CGFloat, </span></span></span><br><span class="line"><span class="function"><span class="params">                after arrangedSubview: UIView)</span></span></span><br></pre></td></tr></table></figure><p>设置指定视图后面的自定义间距</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">let</span> <span class="title">spacingUseDefault</span>: <span class="title">CGFloat</span></span></span><br></pre></td></tr></table></figure><p>stack view里视图之间默认的间距</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">let</span> <span class="title">spacingUseSystem</span>: <span class="title">CGFloat</span></span></span><br></pre></td></tr></table></figure><p>系统定义的相邻视图之间的间距</p></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Uncle Peter</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://yoursite.com/2017/08/09/UIStackView基础知识/">http://yoursite.com/2017/08/09/UIStackView基础知识/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a><a class="post-meta__tags" href="/tags/swift/">swift</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/02/26/swift中map与flatMap的用法与研究/"><i class="fa fa-chevron-left"></i><span>swift中map与flatMap的用法与研究</span></a></div><div class="next-post pull-right"><a href="/2017/07/04/swift中的Initialization/"><span>swift中的Initialization</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2018 By Uncle Peter</div><div class="framework-info"><span>Driven - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Welcome to my blog,have a nice day.</div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script></body></html>